{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArgoCD DevOps Portfolio Project","text":"<p>Professional GitOps Implementation with ArgoCD</p> <p>Portfolio Project</p> <p>This is a professional portfolio project showcasing DevOps expertise with ArgoCD, Kubernetes, Terraform, and GitOps principles.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project demonstrates a complete GitOps workflow using ArgoCD to manage Kubernetes applications. It showcases professional DevOps practices including:</p> <ul> <li>Infrastructure as Code with Terraform for ArgoCD installation</li> <li>GitOps Workflow with declarative application configurations</li> <li>Kubernetes Management using Kind for local development</li> <li>Helm Charts for package management and deployment</li> <li>Multi-Environment Support with environment-specific configurations</li> <li>Task Automation for common operations</li> <li>Comprehensive Documentation for maintainability</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Declarative Application Deployment: Applications defined as code in Git</li> <li>Automated Synchronization: Changes in Git automatically applied to the cluster</li> <li>Environment Management: Separate configurations for different environments</li> <li>Terraform Integration: Infrastructure provisioning with code</li> <li>Helm Chart Management: Standardized application packaging</li> <li>Local Development: Kind cluster for local testing</li> <li>Task Automation: Streamlined workflows with Task runner</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with this project:</p> <ol> <li>Check the Prerequisites for required tools</li> <li>Follow the Getting Started to set up the environment</li> <li>Explore the Architecture Overview to understand the system design</li> </ol>"},{"location":"disclaimer/","title":"Disclaimer","text":"<p>Portfolio Project</p> <p>This is a personal portfolio project created to demonstrate DevOps skills and knowledge to potential employers and recruiters.</p>"},{"location":"disclaimer/#project-purpose","title":"Project Purpose","text":"<p>This ArgoCD demonstration project was created with the following purposes:</p> <ol> <li>Showcase Technical Skills: To demonstrate practical knowledge of GitOps, Kubernetes, ArgoCD, Terraform, and related technologies</li> <li>Portfolio Development: To serve as a concrete example of DevOps best practices for professional portfolio</li> <li>Learning Resource: To document the implementation of ArgoCD in a structured, educational manner</li> </ol>"},{"location":"disclaimer/#not-for-production-use","title":"Not For Production Use","text":"<p>While this project implements many best practices and security considerations, it is designed primarily as a demonstration and learning tool. Some considerations for production environments may include:</p> <ul> <li>Additional security hardening</li> <li>High availability configurations</li> <li>Backup and disaster recovery procedures</li> <li>Monitoring and alerting setup</li> <li>Performance optimization for scale</li> </ul>"},{"location":"disclaimer/#skills-demonstrated","title":"Skills Demonstrated","text":"<p>This project demonstrates proficiency in:</p> <ul> <li>GitOps Principles: Declarative infrastructure and application definitions</li> <li>Kubernetes Administration: Cluster setup, application deployment, and management</li> <li>Infrastructure as Code: Using Terraform to provision infrastructure</li> <li>CI/CD Practices: Automated deployment pipelines</li> <li>Configuration Management: Managing application configurations across environments</li> <li>Documentation: Creating comprehensive technical documentation</li> </ul>"},{"location":"disclaimer/#contact-information","title":"Contact Information","text":"<p>For questions, feedback, or professional inquiries related to this project, please contact:</p> <ul> <li>GitHub: sean-njela</li> <li>LinkedIn: Sean Njela</li> </ul> <p>This project is licensed under the terms of the LICENSE file included in the repository.</p>"},{"location":"architecture/overview/","title":"System Architecture Overview","text":"<p>This document provides a high-level overview of the ArgoCD demonstration project architecture, explaining how the various components interact to implement GitOps principles.</p>"},{"location":"architecture/overview/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TD\n    subgraph \"Git Repository\"\n        A[Application Manifests]\n        B[Helm Charts]\n        C[Infrastructure Code]\n    end\n\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"ArgoCD\"\n            D[ArgoCD Server]\n            E[ArgoCD Repo Server]\n            F[ArgoCD Application Controller]\n            G[ArgoCD Redis]\n            H[ArgoCD Dex Server]\n        end\n\n        subgraph \"Applications\"\n            I[App 1]\n            J[App 2]\n        end\n    end\n\n    subgraph \"Infrastructure\"\n        K[Terraform]\n        L[Kind Cluster]\n    end\n\n    A --&gt;|Source of Truth| E\n    B --&gt;|Chart Templates| E\n    E --&gt;|Manifests| F\n    F --&gt;|Reconciles| I\n    F --&gt;|Reconciles| J\n    K --&gt;|Provisions| D\n    K --&gt;|Provisions| E\n    K --&gt;|Provisions| F\n    K --&gt;|Provisions| G\n    K --&gt;|Provisions| H\n    L --&gt;|Hosts| D</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#git-repository","title":"Git Repository","text":"<p>The Git repository serves as the single source of truth for the entire system, containing:</p> <ul> <li>Application Manifests: Kubernetes manifests defining the desired state of applications</li> <li>Helm Charts: Templated application packages for consistent deployment</li> <li>Infrastructure Code: Terraform configurations for provisioning infrastructure</li> </ul>"},{"location":"architecture/overview/#argocd","title":"ArgoCD","text":"<p>ArgoCD is the GitOps continuous delivery tool that ensures the cluster state matches the desired state defined in Git:</p> <ul> <li>ArgoCD Server: Provides the API and UI for managing applications</li> <li>Repo Server: Responsible for cloning Git repositories and generating Kubernetes manifests</li> <li>Application Controller: Monitors running applications and compares their state to the desired state</li> <li>Redis: Caches repository information and serves as a shared cache</li> <li>Dex Server: Optional component for SSO authentication</li> </ul>"},{"location":"architecture/overview/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<p>The Kubernetes cluster is created using Kind (Kubernetes in Docker) for local development:</p> <ul> <li>Control Plane: Manages the cluster state and API</li> <li>Worker Nodes: Run the application workloads</li> <li>Namespaces: Logical separation of applications and components</li> </ul>"},{"location":"architecture/overview/#infrastructure-management","title":"Infrastructure Management","text":"<ul> <li>Terraform: Provisions and configures ArgoCD in a reproducible manner</li> <li>Task Runner: Automates common operations and workflows</li> </ul>"},{"location":"architecture/overview/#workflow","title":"Workflow","text":"<ol> <li>Development: Changes are made to application code or configuration in Git</li> <li>Commit &amp; Push: Changes are committed and pushed to the Git repository</li> <li>Detection: ArgoCD detects changes in the Git repository</li> <li>Comparison: ArgoCD compares the desired state with the current state</li> <li>Reconciliation: ArgoCD applies changes to bring the cluster to the desired state</li> <li>Monitoring: ArgoCD continuously monitors for drift between desired and actual state</li> </ol>"},{"location":"architecture/overview/#environment-structure","title":"Environment Structure","text":"<p>The project supports multiple environments through directory structure:</p> <pre><code>environments/\n\u251c\u2500\u2500 dev/\n\u2502   \u251c\u2500\u2500 apps/\n\u2502   \u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u2514\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 helm/\n\u2502       \u2514\u2500\u2500 myargoapp-chart/\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Each environment contains: - Application-specific configurations - Environment-specific values - Helm charts for templated applications</p>"},{"location":"architecture/overview/#security-considerations","title":"Security Considerations","text":"<ul> <li>RBAC: Role-Based Access Control for ArgoCD and Kubernetes resources</li> <li>Secure Defaults: ArgoCD is configured with secure default settings</li> <li>Least Privilege: Components operate with minimal required permissions</li> <li>Secrets Management: Sensitive information is properly managed</li> </ul>"},{"location":"architecture/overview/#scalability","title":"Scalability","text":"<p>While this demonstration uses a single-node Kind cluster, the architecture is designed to be scalable:</p> <ul> <li>Horizontal Scaling: Applications can be scaled horizontally</li> <li>Multi-Environment: Structure supports multiple environments (dev, staging, prod)</li> <li>Multi-Cluster: ArgoCD can manage multiple Kubernetes clusters</li> </ul>"},{"location":"architecture/overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>Infrastructure with Terraform</li> <li>ArgoCD Applications</li> <li>ArgoCD Overview</li> </ul>"},{"location":"argocd/applications/","title":"Application Deployment with ArgoCD","text":"<p>This document explains how applications are defined, deployed, and managed using ArgoCD in this project.</p>"},{"location":"argocd/applications/#application-definition","title":"Application Definition","text":"<p>In ArgoCD, applications are defined using the <code>Application</code> custom resource. This project includes two sample applications:</p> <ol> <li>A Helm-based application (<code>0-application.yaml</code>)</li> <li>A Kubernetes manifest-based application (<code>1-application.yaml</code>)</li> </ol>"},{"location":"argocd/applications/#example-application-definition","title":"Example Application Definition","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myargoapp-0\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/dev/helm/myargoapp-chart\n    helm:\n      valueFiles:\n        - values.yaml\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp-0\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre>"},{"location":"argocd/applications/#key-components-of-an-application-definition","title":"Key Components of an Application Definition","text":""},{"location":"argocd/applications/#metadata","title":"Metadata","text":"<ul> <li>name: Unique identifier for the application</li> <li>namespace: The namespace where the ArgoCD Application resource is created (typically <code>argocd</code>)</li> </ul>"},{"location":"argocd/applications/#spec","title":"Spec","text":"<ul> <li>project: The ArgoCD project this application belongs to (default or custom)</li> <li>source: Where to find the application manifests:</li> <li>repoURL: Git repository URL</li> <li>targetRevision: Git revision (branch, tag, commit)</li> <li>path: Path within the repository</li> <li>helm: Helm-specific configuration (if using Helm)</li> <li>destination: Where to deploy the application:</li> <li>server: Target Kubernetes cluster</li> <li>namespace: Target namespace for the application</li> <li>syncPolicy: How ArgoCD should handle synchronization:</li> <li>automated: Settings for automatic synchronization</li> <li>syncOptions: Additional sync options</li> </ul>"},{"location":"argocd/applications/#application-types","title":"Application Types","text":""},{"location":"argocd/applications/#helm-based-applications","title":"Helm-Based Applications","text":"<p>For applications packaged as Helm charts:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/helm/myargoapp-chart\n  helm:\n    valueFiles:\n      - values.yaml\n    parameters:\n      - name: replicaCount\n        value: \"2\"\n</code></pre>"},{"location":"argocd/applications/#kubernetes-manifest-applications","title":"Kubernetes Manifest Applications","text":"<p>For applications defined with plain Kubernetes manifests:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/apps/myapp\n  directory:\n    recurse: true\n    jsonnet: {}\n</code></pre>"},{"location":"argocd/applications/#kustomize-applications","title":"Kustomize Applications","text":"<p>For applications using Kustomize:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/kustomize\n  kustomize:\n    namePrefix: dev-\n    images:\n      - myapp:latest\n</code></pre>"},{"location":"argocd/applications/#sync-policies","title":"Sync Policies","text":""},{"location":"argocd/applications/#manual-sync","title":"Manual Sync","text":"<p>Applications can be configured for manual synchronization:</p> <pre><code>syncPolicy: {}  # No automated sync\n</code></pre> <p>With manual sync, changes must be applied explicitly through the UI or CLI.</p>"},{"location":"argocd/applications/#automated-sync","title":"Automated Sync","text":"<p>For automatic synchronization when changes are detected:</p> <pre><code>syncPolicy:\n  automated:\n    prune: true    # Remove resources that no longer exist in Git\n    selfHeal: true # Revert manual changes made to the cluster\n</code></pre>"},{"location":"argocd/applications/#sync-options","title":"Sync Options","text":"<p>Additional synchronization options:</p> <pre><code>syncPolicy:\n  syncOptions:\n    - CreateNamespace=true    # Create namespace if it doesn't exist\n    - PruneLast=true          # Remove resources last during sync\n    - ApplyOutOfSyncOnly=true # Only apply resources that are out of sync\n</code></pre>"},{"location":"argocd/applications/#application-health","title":"Application Health","text":"<p>ArgoCD monitors the health of deployed applications based on:</p> <ol> <li>Kubernetes resource status</li> <li>Custom health checks</li> <li>Resource-specific health assessments (e.g., Deployments, StatefulSets)</li> </ol> <p>Health status is displayed in the UI and available via the API and CLI.</p>"},{"location":"argocd/applications/#deploying-applications","title":"Deploying Applications","text":""},{"location":"argocd/applications/#using-kubectl","title":"Using kubectl","text":"<pre><code># Apply the Application manifest\nkubectl apply -f 0-application.yaml\n</code></pre>"},{"location":"argocd/applications/#using-argocd-cli","title":"Using ArgoCD CLI","text":"<pre><code># Create application from a manifest\nargocd app create -f 0-application.yaml\n\n# Create application with CLI parameters\nargocd app create myapp \\\n  --repo https://github.com/sean-njela/argocd-demo.git \\\n  --path environments/dev/apps/myapp \\\n  --dest-server https://kubernetes.default.svc \\\n  --dest-namespace myapp\n</code></pre>"},{"location":"argocd/applications/#using-the-argocd-ui","title":"Using the ArgoCD UI","text":"<ol> <li>Navigate to the ArgoCD UI at http://localhost:8080</li> <li>Click \"New App\" in the top left</li> <li>Fill in the application details</li> <li>Click \"Create\"</li> </ol>"},{"location":"argocd/applications/#managing-applications","title":"Managing Applications","text":""},{"location":"argocd/applications/#viewing-application-status","title":"Viewing Application Status","text":"<pre><code># Using kubectl\nkubectl get applications -n argocd\nkubectl describe application myapp -n argocd\n\n# Using ArgoCD CLI\nargocd app get myapp\nargocd app list\n</code></pre>"},{"location":"argocd/applications/#syncing-applications","title":"Syncing Applications","text":"<pre><code># Using ArgoCD CLI\nargocd app sync myapp\n\n# Force sync (overwrite live state)\nargocd app sync myapp --force\n</code></pre>"},{"location":"argocd/applications/#deleting-applications","title":"Deleting Applications","text":"<pre><code># Using kubectl\nkubectl delete application myapp -n argocd\n\n# Using ArgoCD CLI\nargocd app delete myapp\n</code></pre>"},{"location":"argocd/applications/#best-practices","title":"Best Practices","text":"<ol> <li>Use Declarative Definitions: Store Application manifests in Git</li> <li>Environment Separation: Use separate paths or values for different environments</li> <li>Resource Limits: Set appropriate CPU and memory limits</li> <li>Health Checks: Implement proper readiness and liveness probes</li> <li>Namespace Isolation: Use separate namespaces for different applications</li> <li>Sync Windows: Configure sync windows for controlled updates</li> <li>Progressive Delivery: Use canary or blue-green deployments for critical applications</li> </ol>"},{"location":"argocd/applications/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Documentation</li> <li>ArgoCD Overview</li> <li>Environment Management</li> <li>System Architecture</li> </ul>"},{"location":"argocd/environments/","title":"Environment Management with ArgoCD","text":"<p>This document explains how multiple environments are managed in this ArgoCD project using GitOps principles.</p>"},{"location":"argocd/environments/#environment-structure","title":"Environment Structure","text":"<p>The project uses a directory-based approach to manage different environments:</p> <pre><code>environments/\n\u251c\u2500\u2500 dev/                  # Development environment\n\u2502   \u251c\u2500\u2500 apps/             # Kubernetes manifest applications\n\u2502   \u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u2514\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 helm/             # Helm chart applications\n\u2502       \u2514\u2500\u2500 myargoapp-chart/\n\u2514\u2500\u2500 README.md             # Environment documentation\n</code></pre> <p>This structure allows for: - Clear separation between environments - Environment-specific configurations - Consistent application structure across environments - Easy addition of new environments (staging, production, etc.)</p>"},{"location":"argocd/environments/#environment-configuration","title":"Environment Configuration","text":""},{"location":"argocd/environments/#development-environment","title":"Development Environment","text":"<p>The development environment (<code>dev/</code>) is configured for:</p> <ul> <li>Local development using Kind</li> <li>Rapid iteration and testing</li> <li>Minimal resource requirements</li> <li>Debug-friendly settings</li> <li>Automated synchronization</li> </ul>"},{"location":"argocd/environments/#adding-new-environments","title":"Adding New Environments","text":"<p>To add new environments (e.g., staging, production):</p> <ol> <li> <p>Create a new directory under <code>environments/</code>:    <pre><code>mkdir -p environments/staging/apps environments/staging/helm\n</code></pre></p> </li> <li> <p>Copy and modify the base configurations:    <pre><code>cp -r environments/dev/apps/app1 environments/staging/apps/\n</code></pre></p> </li> <li> <p>Update environment-specific values:</p> </li> <li>Resource limits and requests</li> <li>Replica counts</li> <li>Configuration parameters</li> <li> <p>External service endpoints</p> </li> <li> <p>Create environment-specific ArgoCD Applications:    <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myapp-staging\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/staging/apps/app1\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp-staging\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre></p> </li> </ol>"},{"location":"argocd/environments/#environment-isolation","title":"Environment Isolation","text":"<p>Each environment is isolated through:</p> <ol> <li>Namespace Separation: Each environment uses dedicated namespaces</li> <li>Configuration Separation: Environment-specific configurations</li> <li>Resource Quotas: Limits on CPU, memory, and other resources</li> <li>Network Policies: Controlled network access between environments</li> <li>RBAC: Role-based access control for different environments</li> </ol>"},{"location":"argocd/environments/#environment-specific-values","title":"Environment-Specific Values","text":""},{"location":"argocd/environments/#helm-values","title":"Helm Values","text":"<p>For Helm-based applications, environment-specific values are managed through values files:</p> <pre><code># environments/dev/helm/myargoapp-chart/values.yaml\nreplicaCount: 1\nresources:\n  limits:\n    cpu: 100m\n    memory: 128Mi\n  requests:\n    cpu: 50m\n    memory: 64Mi\n</code></pre> <pre><code># environments/staging/helm/myargoapp-chart/values.yaml\nreplicaCount: 2\nresources:\n  limits:\n    cpu: 200m\n    memory: 256Mi\n  requests:\n    cpu: 100m\n    memory: 128Mi\n</code></pre>"},{"location":"argocd/environments/#kustomize-overlays","title":"Kustomize Overlays","text":"<p>For applications using Kustomize, environment-specific configurations are managed through overlays:</p> <pre><code>apps/myapp/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service.yaml\n\u2502   \u2514\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 overlays/\n\u2502   \u251c\u2500\u2500 dev/\n\u2502   \u2502   \u251c\u2500\u2500 kustomization.yaml\n\u2502   \u2502   \u2514\u2500\u2500 patch.yaml\n\u2502   \u2514\u2500\u2500 staging/\n\u2502       \u251c\u2500\u2500 kustomization.yaml\n\u2502       \u2514\u2500\u2500 patch.yaml\n</code></pre>"},{"location":"argocd/environments/#promotion-between-environments","title":"Promotion Between Environments","text":"<p>The project supports promoting applications between environments:</p> <ol> <li>Testing in Development: Applications are first deployed to the development environment</li> <li>Validation: Automated and manual testing verifies the application</li> <li>Promotion: Changes are merged to the staging branch</li> <li>Staging Deployment: ArgoCD automatically deploys to staging</li> <li>Production Approval: Changes are approved for production</li> <li>Production Deployment: ArgoCD deploys to production</li> </ol>"},{"location":"argocd/environments/#environment-specific-sync-policies","title":"Environment-Specific Sync Policies","text":"<p>Different environments can have different sync policies:</p> <ul> <li> <p>Development: Automated sync with self-healing   <pre><code>syncPolicy:\n  automated:\n    prune: true\n    selfHeal: true\n</code></pre></p> </li> <li> <p>Staging: Automated sync with manual approval   <pre><code>syncPolicy:\n  automated:\n    prune: true\n    selfHeal: true\n  syncOptions:\n    - PruneLast=true\n</code></pre></p> </li> <li> <p>Production: Manual sync with sync windows   <pre><code>syncPolicy:\n  syncOptions:\n    - PruneLast=true\n    - ApplyOutOfSyncOnly=true\n</code></pre></p> </li> </ul>"},{"location":"argocd/environments/#environment-variables-and-secrets","title":"Environment Variables and Secrets","text":"<p>Environment-specific secrets and variables are managed through:</p> <ol> <li>Kubernetes Secrets: For sensitive information</li> <li>ConfigMaps: For non-sensitive configuration</li> <li>External Secret Management: Integration with tools like HashiCorp Vault (in production)</li> </ol>"},{"location":"argocd/environments/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent Structure: Maintain the same structure across environments</li> <li>Minimal Differences: Keep environment-specific changes to a minimum</li> <li>Documentation: Document the purpose and configuration of each environment</li> <li>Testing: Test changes in lower environments before promotion</li> <li>Access Control: Implement appropriate access controls for each environment</li> <li>Monitoring: Set up environment-specific monitoring and alerts</li> <li>Disaster Recovery: Implement backup and recovery procedures for each environment</li> </ol>"},{"location":"argocd/environments/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>Application Deployment</li> <li>System Architecture</li> <li>Infrastructure with Terraform</li> </ul>"},{"location":"argocd/image-updater-setup/","title":"Image Updater Setup","text":"<p>Instead of using CLI helm commands, to setup the image updater, we will use a more repeatable IAC solution.</p> <p>We will use terraform to install the image updater. (same as we did for argocd)</p> <p>An ssh key is required for the image updater to work. We will also give it write access to the git repo as we will want to experiement with both git write back methods. This allows the image updater to update the git infra repo with the new image tags.</p> <p>Delete the key after experiementation is done</p> <p>Since this is a public repo, the key should be deleted after experiementation is done.</p> <p>Whether we are using private or public docker repos it is the same process. But we will need to provide the image updater with the credentials to access the private repo. </p> <p>We will be using helm charts in this project, although it is possible to use raw k8s manifests or Kustomize, we will use helm charts as it is what I am most comfortable with.</p> <p>We will show how to use git repositories in a gitops workflow as well as using helm repositories directly.</p> <p>The approach is the same when using private docker repos</p> <p>We will need to provide the deployment with the credentials to access the private docker repo, because without it will not be able to pull the image. (read only token is best practice). Then run: <pre><code>kubectl create secret docker-registry dockerconfigjson -n argocd --docker-server=docker.io/v1/ --docker-username=devopssean --docker-password=&lt;your_read_only_token&gt; --docker-email=sean-njela@yahoo.com\n</code></pre> The updater also needs to access the private repo. So we add the secret name (name: dockerconfigjson) to our deployment manifest (under spec-template-spec-ImagePullSecrets), and we also need to change the image registry in the manifests to point to the private docker repo. ArgoCD Image updater supports multiple registries. So we create and apply a docker secret for our token(<code>0-docker-secret.yaml</code>) in the argocd namespace. We will then need to add the following to the values file in the terraform <code>0-image-updater.yaml</code> file: <pre><code>config:\n  registries:\n    - name: dockerhub\n      api_url: https://registry-1.docker.io\n      ping: yes\n      credentials: secret:argocd/dockerhub-token#my-token\n      limit: 20 # Rate limit\n      default: true # Or we can use annotations in each application to specify the registry to use.\n</code></pre> Then <code>tf apply</code></p> <p>We replaced the https repoURL with an SSH repoURL in the my-argocd-app0.yaml file as argocd-image-updater will be using a key to access and push the new image to the repo.</p> <pre><code>repoURL: ssh://git@github.com/sean-njela/argocd-demo.git\n</code></pre>"},{"location":"argocd/image-updater-setup/#annotations","title":"Annotations","text":"<p>using an annotation, we define the list of container images that should be automatically updated in a Kubernetes deployment managed by Argo CD. Its value is a comma-separated list of image names (and optionally tags or configuration options).</p> <p>Example: <pre><code>annotations:\n  argocd-image-updater.argoproj.io/image-list: myapp=myregistry.io/myapp,sidecar=nginx\n</code></pre> This example tells Argo CD Image Updater to:</p> <ul> <li>Track the myregistry.io/myapp image and label it as myapp.</li> <li>Track the nginx image and label it as sidecar.</li> </ul> <p>Each of these labels corresponds to container names in the Kubernetes deployment spec.</p> <p>\ud83d\udd0d Why? Argo CD Image Updater needs to know which container in your Deployment to update. It uses the key in the image-list annotation (like myapp) to map to a container name inside your Kubernetes resource.</p> <p>Example: Suppose your deployment looks like this:</p> <p><pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\nspec:\n  template:\n    spec:\n      containers:\n        - name: myapp\n          image: myregistry.io/myapp:v0.4.1\n</code></pre> Then you would configure Argo CD Image Updater like this:</p> <pre><code>annotations:\n  argocd-image-updater.argoproj.io/image-list: myapp=myregistry.io/myapp:~1.0\n</code></pre> <p>Here\u2019s what happens:</p> <ul> <li><code>myapp</code> in the annotation matches the name: <code>myapp</code> container in the Deployment.</li> <li>Argo CD Image Updater checks for new tags (like v0.4.2) and updates the image if one is available.</li> <li>The update is done in the Git repo (if using GitOps) or live, depending on your configuration.</li> </ul> <p>\u274c If They Don't Match? If the annotation says:</p> <p><pre><code>argocd-image-updater.argoproj.io/image-list: wrongname=myregistry.io/myapp\n</code></pre> ...but the container in the Deployment is named <code>myapp</code>, nothing will be updated. Argo CD Image Updater will log a warning like:</p> <pre><code>Could not find container with name 'wrongname' in workload ...\n</code></pre> <p>TL;DR</p> <p>The key (myapp) must match a container name in the manifest.</p> <p>It tells Argo CD Image Updater exactly which container to update.</p> <p>In our case:</p> <p><pre><code>annotations:\n    argocd-image-updater.argoproj.io/image-list: argocd-app=docker.io/devopssean/zta_demo_app:1.x\n</code></pre> You can also add other annotations to fine-tune the behavior:</p> <pre><code>annotations:\n  argocd-image-updater.argoproj.io/image-list: argocd-app=docker.io/devopssean/zta_demo_app:1.x\n  argocd-image-updater.argoproj.io/argocd-app.update-strategy: semver\n  argocd-image-updater.argoproj.io/write-back-method: git\n</code></pre> <p>This annotation is essential when you want Argo CD Image Updater to:</p> <ul> <li>Monitor specific container images.</li> <li>Automatically update the Argo CD Application when a new version is available (based on your strategy).</li> </ul> <p><code>argocd-app=nanajanashia/argocd-app</code>: Tells Argo CD Image Updater to track the image nanajanashia/argocd-app and associate it with the container named argocd-app.</p> <p><code>update-strategy: semver</code>: Instructs the updater to sort and evaluate available tags using semantic versioning rules (e.g., 1.0.1 &lt; 1.0.2 &lt; 1.1.0).</p> <p><code>allow-tags: ^1</code> Allows only tags that:</p> <ul> <li>Are greater than or equal to 1.0.0</li> <li>Are less than 2.0.0</li> </ul> <p>This includes:</p> <ul> <li>1.0.0, 1.1.5, 1.9.99</li> </ul> <p>This excludes:</p> <ul> <li>2.0.0, 0.9.9, latest, or non-semver tags</li> </ul> <p><code>write-back-method: git</code> Ensures changes are committed back to the Git repo (true GitOps behavior).</p> <p>If your tags do start with v (e.g., v1.0.0)</p> <p>Then semver strategy will not match those by default. You would need to either:</p> <ul> <li> <p>Strip the v from your tag format at the registry level, or</p> </li> <li> <p>Switch to update-strategy: latest and use a regex:</p> </li> </ul> <pre><code>argocd-image-updater.argoproj.io/myapp.update-strategy: latest\nargocd-image-updater.argoproj.io/myapp.allow-tags: regexp:^v1\\.[0-9]+\\.[0-9]+$\n</code></pre> <p>You also need to tell Argo CD Image Updater where in the values.yaml file the image and tag are located.</p> <p>You must add:</p> <p><pre><code>argocd-image-updater.argoproj.io/myapp.helm-image-tag-spec: image.tag\nargocd-image-updater.argoproj.io/myapp.helm-image-name-spec: image.repository\n</code></pre> These are required when you're not using inline Helm parameters:.</p> <p>Final Correct Version (when using a values file): <pre><code>annotations:\n  argocd-image-updater.argoproj.io/image-list: argocd-app=docker.io/devopssean/zta_demo_app:1.x\n  argocd-image-updater.argoproj.io/argocd-app.update-strategy: semver\n  argocd-image-updater.argoproj.io/argocd-app.helm-image-tag-spec: image.tag\n  argocd-image-updater.argoproj.io/argocd-app.helm-image-name-spec: image.repository\n  argocd-image-updater.argoproj.io/write-back-method: git\n</code></pre></p> <p>Why this matters: If you don\u2019t include those helm-image-* annotations, Argo CD Image Updater has no way of knowing what to modify inside your values.yaml.</p> <p>And your values.yaml should look like:</p> <pre><code>image:\n  repository: docker.io/devopssean/zta_demo_app\n  tag: \"1.0.0\"\n</code></pre>"},{"location":"argocd/image-updater-setup/#sealed-secrets","title":"Sealed Secrets","text":"<p>In the first instance we used a k8s secret manifest with the ssh private key to access the git repo. But later we will use sealed secrets to store the private key. </p> <p>The secret should be applied first before bootstrapping argocd.</p>"},{"location":"argocd/image-updater/","title":"Argo CD Image Updater","text":""},{"location":"argocd/image-updater/#overview","title":"Overview","text":"<p>Argo CD Image Updater is a tool that automatically updates container images in your Kubernetes cluster based on the latest available versions in your container registry. It helps keep your applications up to date with the latest security patches and bug fixes.</p> <p>There are two write-back methods supported by Argo CD Image Updater, which define where the image update changes are applied:</p>"},{"location":"argocd/image-updater/#argo-cd-image-updater-write-back-methods","title":"\ud83d\udd04 Argo CD Image Updater: Write-Back Methods","text":"<p>There are two primary write-back methods:</p>"},{"location":"argocd/image-updater/#1-git-write-back-gitops-mode","title":"1. Git Write-Back (GitOps Mode) \u2705","text":"<p>This is the default and recommended method, fully aligned with GitOps principles.</p>"},{"location":"argocd/image-updater/#how-it-works","title":"\ud83d\udee0 How it works:","text":"<ul> <li>Image Updater detects a new image version.</li> <li>It modifies the Kubernetes manifest or Helm values file in the Git repository.</li> <li>Commits and pushes the change to Git.</li> <li>Argo CD (which continuously watches Git) detects the change and applies it to the cluster.</li> </ul>"},{"location":"argocd/image-updater/#pros","title":"\u2705 Pros:","text":"<ul> <li>Git remains the source of truth.</li> <li>Full audit history via Git commits.</li> <li>Works well with review processes, PRs, and version control tools.</li> <li>Clean separation of change and deployment.</li> </ul>"},{"location":"argocd/image-updater/#requirements","title":"\ud83d\udd10 Requirements:","text":"<ul> <li>Access to Git repo with push privileges (via SSH key or token).</li> <li>Correct annotations for image list, strategy, and write-back config.</li> </ul>"},{"location":"argocd/image-updater/#2-direct-cluster-update-argo-cd-api-mode","title":"2. Direct Cluster Update (Argo CD API Mode) \u26a0\ufe0f","text":"<p>This is a more imperative approach, where the image updater bypasses Git and directly patches the live application in the Kubernetes cluster via the Argo CD API.</p>"},{"location":"argocd/image-updater/#how-it-works_1","title":"\ud83d\udee0 How it works:","text":"<ul> <li>Detects a new image version.</li> <li>Uses the Argo CD API to patch the image parameter of the running app.</li> <li>Change is applied directly to the live Kubernetes app (stored in Argo CD\u2019s state), but not recorded in Git.</li> </ul>"},{"location":"argocd/image-updater/#pros_1","title":"\u26a0\ufe0f Pros:","text":"<ul> <li>Fastest way to update running workloads.</li> <li>Doesn\u2019t require Git access.</li> </ul>"},{"location":"argocd/image-updater/#cons","title":"\u274c Cons:","text":"<ul> <li>Violates GitOps principles \u2014 Git is no longer the single source of truth.</li> <li>Changes will be overwritten if Argo CD auto-syncs from Git later.</li> <li>No Git commit/audit trail of what was deployed.</li> </ul>"},{"location":"argocd/image-updater/#use-case","title":"\u2699\ufe0f Use case:","text":"<ul> <li>Temporary patches or urgent updates where Git isn\u2019t accessible.</li> <li>Testing environments.</li> </ul>"},{"location":"argocd/image-updater/#summary-table","title":"\ud83d\udcdd Summary Table","text":"Method Description GitOps-Friendly Persisted in Git Recommended For Git Write-Back Updates manifests in Git \u2705 Yes \u2705 Yes Production, CI/CD Direct Cluster Updates Argo CD app live via API \u274c No \u274c No Dev/test, emergencies"},{"location":"argocd/image-updater/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>Specify the write-back method via annotations or config file:</p> <pre><code>argocd-image-updater.argoproj.io/write-back-method: git\n</code></pre> <p>or</p> <pre><code>argocd-image-updater.argoproj.io/write-back-method: argocd\n</code></pre> <p>Next, check out Argo CD Image Updater Setup</p>"},{"location":"argocd/notifications/","title":"\ud83d\udd14 Argo CD Notifications","text":"<p>\ud83c\udfaf What Is It?</p> <p>A mechanism for sending real-time updates (e.g. via Slack, email, webhooks) when changes occur in Argo CD apps.</p> <p>\ud83e\udde0 Why Use It?</p> <ul> <li>Alerts stakeholders/devs on app syncs, health changes, or failures</li> <li>Prevents silent failures in CD pipelines</li> <li>Enables traceability and rapid incident response</li> <li>Integrates GitOps events into team workflows</li> </ul> <p>\ud83c\udfe0 Real-World USE CASE</p> <p>In a DevOps team managing microservices with Argo CD, when a deployment fails due to drift or Helm chart issues, a Slack alert is sent instantly. This lets the responsible dev fix it before it hits production or CI breaks.</p> <p>\ud83d\udd27 How It Works</p> <ol> <li>Install <code>argocd-notifications</code> controller (either bundled with Argo CD or as a sidecar)</li> <li>Configure Triggers: conditions like \u201csync failed\u201d, \u201chealth degraded\u201d</li> <li>Set up Templates: what the message looks like</li> <li>Define Subscriptions: who gets notified (e.g. Slack, Teams, Email)</li> <li>Apply config as Kubernetes <code>ConfigMap</code> or <code>Secret</code></li> </ol> <p>\ud83d\udca1 Code Example (K8s Manifest Snippet)</p> <pre><code># notifications-cm.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argocd-notifications-cm\n  labels:\n    app.kubernetes.io/name: argocd-notifications-cm\ndata:\n  service.slack: |\n    token: $slack-token   # from Secret\n  trigger.on-sync-failed: |\n    - when: app.status.operationState.phase in ['Failed']\n      send: [slack-message]\n  template.slack-message: |\n    message: |\n      Application {{.app.metadata.name}} sync **FAILED**\n      \ud83d\udea8 Reason: {{.app.status.operationState.message}}\n</code></pre> <pre><code># notifications-secret.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: argocd-notifications-secret\nstringData:\n  slack-token: \"&lt;xoxb-your-slack-bot-token&gt;\"\n</code></pre> <p>\ud83d\udd0d Key Strengths</p> <ul> <li>Native GitOps integration</li> <li>Lightweight (controller runs as small Go service)</li> <li>Customisable triggers and messages</li> <li>Works with any messaging system via webhook</li> </ul> <p>\u26a0\ufe0f Watch Outs &amp; Critical Analysis</p> <ul> <li>Lack of Granular ACLs: All notification configs are global</li> <li>Hard to Test Locally: Requires real Argo CD state changes</li> <li>Limited Built-in Templates: Must build message templates from scratch</li> <li>Message Spam Risk: Poor trigger logic = notification fatigue</li> <li>Alert Routing Complexity: Slack channels or email groups may need to be tightly controlled</li> </ul> <p>\ud83d\udd00 Best Practical Approach</p> <p>\u2705 Use only critical triggers (sync failures, degraded health) \u2705 Create modular templates to reuse messages \u2705 Route alerts to a central DevOps Slack channel, not individuals \u2705 Leverage webhooks for forwarding to incident tools (e.g. PagerDuty) \u2705 Validate templates using Argo CD CLI (<code>argocd-notifications template render</code>)</p> <p>\ud83d\udeab Do not notify on every sync\u2014creates noise \ud83d\udeab Avoid Slack mentions in production unless tied to alerts/escalation policies</p> <p>\ud83d\udcda Related Topics</p> <ul> <li>Argo CD (core)</li> <li>GitOps</li> <li>Prometheus Alertmanager (if using metric-based alerting)</li> <li>Kubernetes ConfigMaps/Secrets</li> <li>Slack Bots/Webhooks</li> </ul> <p>Many intergrations are available but we will be using slack for this example. But the process is the same for other integrations.</p> <p>First create a slack app using <code>api.slack.com/apps?deleted=1</code> and selecting the from scratch option. Name it argocd, choose a workspace and head to oauth to grant the app the necessary permissions to post to slack channels under <code>bot token</code> scope. (chat:write and chat:write.customise). Then scroll up and click install to workspace. </p> <p>Copy the bot token and save it in a secret file. <code>0-notifications-secret.yaml</code>. The secret name and namespace must be <code>argocd-notifications-secret</code> and <code>argocd</code> respectively. For the configmap <code>0-notifications-cm.yaml</code> as well the name and namespace must be <code>argocd-notifications-cm</code> and <code>argocd</code> respectively.</p> <p>In the app <code>my-argocd-app2</code> we will need to add annotations to enable notifications.</p> <pre><code>notifications.argoproj.io/subscribe.on-deployed.slack: alerts \nnotifications.argoproj.io/subscribe.on-sync-failed.slack: alerts \n</code></pre> <p>There are many more than this. You can find them in the Argo CD Notifications documentation.</p> <p>Now add a channel in slack named <code>alerts</code> and add the bot to it. Most of teh time it will be private but for this example we will use public. We will need to add the bot to the channel ( <code>hey @&lt;bot name&gt;</code> in the channel ) and then add when prompted.</p> <p>Then apply the secret, configmp.</p>"},{"location":"argocd/overview/","title":"ArgoCD Overview","text":"<p>This document provides a comprehensive overview of ArgoCD as implemented in this project, explaining its components, architecture, and how it enables GitOps workflows.</p>"},{"location":"argocd/overview/#what-is-argocd","title":"What is ArgoCD?","text":"<p>ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It automates the deployment of applications to Kubernetes by keeping the cluster state in sync with configuration stored in Git repositories.</p> <p>It is best to reference the officical ArgoCD documentation for more information. ArgoCD Documentation</p>"},{"location":"argocd/overview/#core-principles","title":"Core Principles","text":"<p>The implementation in this project adheres to the following GitOps principles:</p> <ol> <li>Declarative Configuration: All system configurations are defined declaratively</li> <li>Version Controlled: All configurations are stored in Git</li> <li>Automated Synchronization: Changes to the desired state are automatically applied</li> <li>Self-Healing: System continuously attempts to converge to the desired state</li> <li>Observability: System state and history are observable and auditable</li> </ol>"},{"location":"argocd/overview/#argocd-architecture","title":"ArgoCD Architecture","text":"<pre><code>graph TD\n    A[API Server] --&gt; B[Repository Server]\n    A --&gt; C[Application Controller]\n    D[Redis] &lt;--&gt; A\n    D &lt;--&gt; B\n    D &lt;--&gt; C\n    E[Git Repository] &lt;-- Polls --&gt; B\n    C --&gt; F[Kubernetes API]\n    G[User] --&gt; A\n    H[Dex] &lt;-- Auth --&gt; A</code></pre>"},{"location":"argocd/overview/#components","title":"Components","text":"<ul> <li>API Server: REST API server that exposes the API consumed by the Web UI, CLI, and CI/CD systems</li> <li>Repository Server: Internal service that maintains a local cache of Git repositories</li> <li>Application Controller: Kubernetes controller that continuously monitors running applications and compares their state against the desired state</li> <li>Redis: Caches repository data and serves as a shared cache for the API server and application controller</li> <li>Dex: Optional OpenID Connect provider for SSO integration</li> </ul>"},{"location":"argocd/overview/#installation","title":"Installation","text":"<p>In this project, ArgoCD is installed using Terraform with the official Helm chart:</p> <pre><code>resource \"helm_release\" \"argocd\" {\n    name = \"argocd\"\n    repository = \"https://argoproj.github.io/argo-helm\"\n    chart = \"argo-cd\"\n    version = \"3.35.4\"\n    namespace = \"argocd\"\n    create_namespace = true\n    values = [file(\"values/argocd-values.yaml\")]\n}\n</code></pre> <p>The installation creates the following resources: - ArgoCD namespace - Core ArgoCD components (server, repo server, application controller) - RBAC resources - Service accounts - ConfigMaps for configuration - Secrets for sensitive data</p>"},{"location":"argocd/overview/#application-definition","title":"Application Definition","text":"<p>Applications in ArgoCD are defined using the <code>Application</code> custom resource:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myapp\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/dev/apps/myapp\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre> <p>Key fields in an Application definition: - source: Where the application manifests are stored - destination: The target Kubernetes cluster and namespace - syncPolicy: How ArgoCD should sync the application</p>"},{"location":"argocd/overview/#sync-strategies","title":"Sync Strategies","text":"<p>This project demonstrates several sync strategies:</p> <ol> <li>Manual Sync: Changes are applied only when manually triggered</li> <li>Automated Sync: Changes are automatically applied when detected</li> <li>Self-Healing: Drift from the desired state is automatically corrected</li> <li>Pruning: Resources no longer defined in Git are removed</li> </ol>"},{"location":"argocd/overview/#application-projects","title":"Application Projects","text":"<p>ArgoCD Projects provide a logical grouping of applications and define constraints for: - Source repositories - Destination clusters and namespaces - Permitted resource kinds - Parameters that can be set</p>"},{"location":"argocd/overview/#user-interface","title":"User Interface","text":"<p>The ArgoCD UI provides: - Application dashboard - Application details and status - Sync and rollback operations - Resource tree view - Application logs - Events and history</p> <p>Access the UI by running: <pre><code>task forward-argocd-ui\n</code></pre></p> <p>Then navigate to http://localhost:8080.</p>"},{"location":"argocd/overview/#cli-access","title":"CLI Access","text":"<p>ArgoCD provides a CLI for interacting with applications:</p> <pre><code># Login to ArgoCD\nargocd login localhost:8080\n\n# List applications\nargocd app list\n\n# Get application status\nargocd app get myapp\n\n# Sync an application\nargocd app sync myapp\n</code></pre>"},{"location":"argocd/overview/#security-considerations","title":"Security Considerations","text":"<p>This implementation includes several security best practices:</p> <ul> <li>RBAC for access control</li> <li>Secure admin password generation</li> <li>TLS for API server (in production)</li> <li>Resource constraints</li> <li>Least privilege principle</li> </ul>"},{"location":"argocd/overview/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>ArgoCD provides several ways to monitor applications:</p> <ul> <li>Health status in the UI</li> <li>Application events</li> <li>Resource tree with status</li> <li>Sync history</li> <li>Integration with Prometheus (in production)</li> </ul>"},{"location":"argocd/overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>Application Deployment</li> <li>Environment Management</li> <li>System Architecture</li> <li>Infrastructure with Terraform</li> </ul>"},{"location":"argocd/production/","title":"And then there was Production...","text":"<p>We will use a python script to freeze the environment until we are ready to deploy to production. In the manual version we will need to add an ignore-tags annotation to everuy app we have deployed which is not ideal.</p> <p>How the script works:</p> <ol> <li>When ready to deploy, <code>pause</code> will create a new branch and add ignore annotations to all apps in the environment. Then create a pull request.</li> <li>Merging this pull request will freeze teh environment.</li> <li>Then run the script again by stating a source environment and a destination environment to prepare production push. This creates a pullrequest for the production push. </li> <li>Merging this pull request will push to production </li> <li>Then we run the script to create a pull request to unfreeze the environment.</li> </ol> <p>We seperated the development(kind) terraform config files from the production(EKS) terraform config files. This is to prevent any accidental changes to the production environment.</p> <p>Create EC repositories in the AWS console. Replace the <code>api_url</code> and <code>prefix</code> with those of the ECR repo in the image-updater.yaml file in the values folder of the prod environment. </p> <p>the first step after provisioning is to give your local kubernetes config access to teh EKS cluster.:</p> <pre><code>aws eks update-kubeconfig --name prod-demo --region eu-north-1\n</code></pre> <p><code>&lt;env&gt;-&lt;name&gt; -&gt; prod-demo</code></p> <p>Then run this command in the image updater pod shell:</p> <p><pre><code> aws ecr --region eu-north-1 get-authorization-token --output text --query 'authorizationData[].authorizationToken' | base64 -d\n</code></pre> If you get any errors restart the pod, and if persistant, double check your configuration.</p> <p>Replace docker hub in the <code>my-argocd-app3.yaml</code> file with the ECR repo. </p> <p>We do not have annotations or CD in production apps. We always have CDel.</p>"},{"location":"argocd/production/#deploying-docker-images","title":"Deploying Docker Images","text":"<p>You will need to provide docker with ECR credentials to be able to push to the ECR. the easiest way is to clisck the repository and click <code>view push commands</code></p> <p>1.</p> <pre><code>aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 699475925123.dkr.ecr.eu-north-1.amazonaws.com\n</code></pre> <p><code>sh docker tag devopssean/zta_demo_app:dev 699475925123.dkr.ecr.eu-north-1.amazonaws.com/devopssean/zta_demo_app1:1.5.0 docker push 699475925123.dkr.ecr.eu-north-1.amazonaws.com/devopssean/zta_demo_app1:1.5.0</code></p> <p><code>sh docker tag devopssean/zta_demo_app:dev 699475925123.dkr.ecr.eu-north-1.amazonaws.com/devopssean/zta_demo_app2:2.5.0 docker push 699475925123.dkr.ecr.eu-north-1.amazonaws.com/devopssean/zta_demo_app2:2.5.0</code></p>"},{"location":"argocd/sealed-secrets/","title":"Sealed Secrets","text":""},{"location":"argocd/sealed-secrets/#sealed-secrets","title":"Sealed Secrets","text":"<p>Sealed Secrets allow us to store our secrets in git and it allows us to encrypt sensitive data in your Kubernetes cluster. </p> <p>In our case we will use Sealed Secrets Controller to encrypt our secrets.</p> <p>We will use the public key to encrypt our secrets and controller will use its private key to decrypt the secrets.</p>"},{"location":"argocd/sealed-secrets/#walkthrough","title":"Walkthrough","text":"<p>Just as we always do when adding helm charts to our cluster, we add a terrfaorm resource to provision and manage the sealed secrets controller. (<code>4-sealed-secrets.tf</code>) Then <code>tf apply</code>. We will provision the sealed secrets controller in the <code>kube-system</code> namespace. It will be essential for the <code>kubeseal</code> CLI tool.</p> <pre><code>resource \"helm_release\" \"sealed-secrets\" {\n    repository = \"https://charts.bitnami.com/bitnami\"\n    name = \"sealed-secrets\"\n    namespace = \"kube-system\"\n    chart = \"sealed-secrets\"\n    version = \"1.2.11\"\n    create_namespace = true\n    values = [file(\"values/sealed-secrets.yaml\")]\n}\n</code></pre> <p>Reminder</p> <p>You can use the helm show values command to see the values that you can edit in a helm chart. But first, you must add the repository to your helm repo list and update. For example: <pre><code>helm repo add argocd https://argoproj.github.io/argo-helm\nhelm repo update\nhelm show values argocd/argocd-image-updater --version 0.1.0 &gt; show-argo-values.yaml\n</code></pre></p> <pre><code>kubectl get pods -n kube-system | grep sealed-secrets # to verify that the sealed secrets controller is running and installled correctly\n</code></pre> <p>Kubeseal will use the following service to get a public key to encrypt our secrets:</p> <pre><code>kubectl get svc sealed-secrets -n kube-system\n</code></pre>"},{"location":"argocd/sealed-secrets/#new-workflow","title":"New Workflow","text":"<p>Remmeber the repo secret 0-repo-secret.yaml? Well, in this new workflow, we will delete it from the cluster:</p> <pre><code>kubectl delete secret -n argocd -f 0-repo-secret.yaml\n</code></pre> <p>and use kubeseal to encrypt the file.</p> <p><pre><code>kubeseal --controller-name sealed-secrets -o yaml -n kube-system &lt; path-to/0-repo-secret.yaml &gt; path-to/1-sealed-repo-secret.yaml\n</code></pre> <code>1-sealed-repo-secret.yaml</code> is the encrypted secret.</p> <p>Then:</p> <pre><code>kubectl apply -f path-to/1-sealed-repo-secret.yaml -n argocd\n</code></pre> <p>The secret becomes safe to keep even in git. The secret can only be used with this cluster and no other because it is encrypted with the public key of this cluster. The secret can be used with the a private repo too.</p>"},{"location":"argocd/using-helm-repo/","title":"Pulling from a helm repo","text":""},{"location":"argocd/using-helm-repo/#using-a-helm-repo","title":"Using a helm repo","text":"<p>Using a helm repo is the same as using a git repo. In this case we will use ChartMuseum as a helm repo to store our helm charts.</p> <p>Reminder</p> <p>You can use the helm show values command to see the values that you can edit in a helm chart. But first, you must add the repository to your helm repo list and update. For example: <pre><code>helm repo add argocd https://argoproj.github.io/argo-helm\nhelm repo update\nhelm show values argocd/argocd-image-updater --version 0.1.0 &gt; show-argo-values.yaml\n</code></pre></p> <p>We will also add a terraform resource <code>3-chartmuseum.tf</code> to provision and manage the chartmuseum instance (this is where we can state the values to override in the values directory). </p> <p>Inorder to upload our chart we will need to package it first. Then use curl with binary data to upload the chart to the chartmuseum instance.:</p>"},{"location":"argocd/using-helm-repo/#what-is-helm-package","title":"What is helm package?","text":"<p>Helm package is a command that packages a chart directory (containing Chart.yaml, templates/, etc.) into a .tgz archive file.</p>"},{"location":"argocd/using-helm-repo/#default-working-directory","title":"\ud83d\udcc1 Default Working Directory","text":"<p>By default, <code>helm package &lt;chart-path&gt;</code> writes the .tgz file to your current working directory.</p> <pre><code>helm package ./mychart\n</code></pre> <p>This will produce a file like ./mychart-0.1.0.tgz.</p>"},{"location":"argocd/using-helm-repo/#changing-the-output-destination","title":"\ud83d\uddc2\ufe0f Changing the Output Destination","text":"<p>You can override the default output location using the <code>-d</code>, <code>--destination &lt;dir&gt;</code> flag, which tells Helm to place the generated archive into the directory you specify:</p> <pre><code>helm package ./mychart -d ./output-charts/\n</code></pre> <p>This will produce a file like ./output-charts/mychart-0.1.0.tgz.</p>"},{"location":"argocd/using-helm-repo/#changing-the-output-destination_1","title":"\ud83d\uddc2\ufe0f Changing the Output Destination","text":"<p>You can override the default output location using the <code>-d</code>, <code>--destination &lt;dir&gt;</code> flag, which tells Helm to place the generated archive into the directory you specify :</p> <pre><code>helm package ./mychart -d ./output-charts/\n</code></pre> <p>This will produce a file like ./output-charts/mychart-0.1.0.tgz. There are many reasons to use the <code>--destination</code> flag:</p> <ul> <li> <p>\ud83d\udce6 1. Organization and Cleanup By default, Helm writes the .tgz to your current directory (.). Using --destination ./charts/ keeps your project root clean and groups all chart archives in one place </p> </li> <li> <p>\ud83d\udee0\ufe0f 2. CI/CD and Automation     In automated pipelines, you\u2019ll often:</p> <pre><code>- Generate artifacts into a build directory (e.g., build/ or dist/)\n- Package multiple charts into structured folders\n- Push the resulting .tgz files to artifact storage\n</code></pre> <p>Changing the destination helps integrate chart packaging into the rest of your build/deployment process.</p> </li> <li> <p>\ud83d\uddc2\ufe0f 3. Multiple Chart Outputs</p> <p>If you package several charts in one go (helm package ./chartA ./chartB), --destination ensures they all land in a shared output folder, instead of cluttering various locations.</p> </li> <li> <p>\ud83e\udde9 4. Chart Repositories</p> <p>When hosting your own Helm repo (via helm repo index), you\u2019ll want all .tgz files in a single directory. Using --destination is essential to aggregate them before indexing them</p> </li> </ul>"},{"location":"argocd/using-helm-repo/#walkthrough","title":"Walkthrough","text":"<p>In our case:</p> <p><pre><code>helm package ./environments/dev/helm/myargoapp-chart -d ./packaged-charts/\n</code></pre> Then </p> <p><pre><code>curl --data-binary @\"./packaged-charts/my-argocd-app-0.1.0.tgz\" http://localhost:8083/api/charts\n</code></pre> You should get a JSON response like:</p> <pre><code>{\"saved\": true}\n</code></pre> <p>Important</p> <p>The output package will be named after the name in the Chart.yaml not the chart directory.</p> <p>Key point</p> <p>The <code>@</code> before the file path is essential! Without it, curl sends the filename as literal data, not the contents of the file Make sure to wrap the file path in quotes, especially if it contains special characters or spaces. ChartMuseum\u2019s API endpoint <code>/api/charts</code> expects the raw binary of the .tgz file </p> <p>To verify that the chart was uploaded successfully, you can use the following command:</p> <pre><code>helm repo add my-uploaded-chart http://localhost:8083\nhelm repo update\nhelm search repo my-uploaded-chart\n</code></pre> <p>Or</p> <pre><code>curl http://localhost:8083/api/charts\n</code></pre> <p>Or </p> <pre><code>curl http://localhost:8083/api/charts/my-argocd-app\n</code></pre>"},{"location":"argocd/using-helm-repo/#connecting-to-argo-cd","title":"Connecting to Argo CD","text":"<p>We will connect a seperate application <code>my-argocd-app2.yaml</code> to pull from the chartmuseum instance. We will use the same annotation and the same docker image. But we will replace the git source repoURL with the chartmuseum repoURL. Instead of specifying the git branch we will specify the version (targetrevision) of our uploaded chart. We will also use the chart name instead of path.  </p> <p>Old:</p> <pre><code>spec:\n  source:\n    repoURL: ssh://git@github.com/sean-njela/argocd-demo.git\n    targetRevision: main # branch to deploy from (or HEAD for latest commit)\n    path: environments/dev/helm/myargoapp-chart # path to the helm chart (app0)\n</code></pre> <p>New:</p> <pre><code>spec:\n  source:\n    repoURL: http://chartmuseum.chartmuseum.svc.cluster.local:8080\n    targetRevision: 0.1.0\n    chart: my-argocd-app # chart name in Chart.yaml\n</code></pre> <p>Key point</p> <p>\ud83e\udde0 http://chartmuseum.chartmuseum.svc.cluster.local is a Kubernetes internal DNS name that points to the ChartMuseum service.</p> <p>It breaks down like this:</p> Part Meaning chartmuseum The Service name chartmuseum (again) The Namespace where the Service lives svc Short for \u201cService\u201d cluster.local Default internal DNS domain of the cluster 8080 Port number (avoids DNS lookup issues when pulling from chartmuseum) <p>\u2705 This format allows other pods (like Argo CD) to access the ChartMuseum service inside the cluster without needing external IPs or port-forwarding.</p> <p>We then apply the app of apps again. But the code must be pushed first.</p> <p>To push a new version just change the version in the Chart.yaml file and in the <code>helm-package-push</code> task and then run the following command:</p> <pre><code>task helm-package-push\n</code></pre>"},{"location":"argocd/using-helm-repo/#argo-cd-chart-sync-behavior","title":"Argo CD Chart Sync Behavior","text":"<p>\u274c By default: Argo CD pulls the version defined in your Application manifest.</p> <p>It does not auto-upgrade when a new version is pushed to ChartMuseum.</p> <p>For example, in your Application.yaml (or values in UI), you might have:</p> <p><pre><code>source:\n  repoURL: http://chartmuseum.chartmuseum.svc.cluster.local\n  chart: my-argocd-app # chart name in Chart.yaml\n  targetRevision: 0.1.0  # \ud83d\udc48 Argo CD will stick to this version\n</code></pre> Even if you push 0.1.1, Argo CD will stay on 0.1.0 unless told otherwise.</p>"},{"location":"argocd/using-helm-repo/#options-to-automatically-use-the-new-version","title":"Options to Automatically Use the New Version","text":"<ol> <li>Use <code>targetRevision: latest</code>     This tells Argo CD to always use the newest available chart version:</li> </ol> <pre><code>source:\n  chart: my-argocd-app  # chart name in Chart.yaml\n  targetRevision: latest\n</code></pre> <p>Warning</p> <p>Be cautious \u2014 this means every new chart version will be picked up automatically, which can be risky in production.</p> <ol> <li> <p>Manually update the version</p> <p>You can:</p> <ul> <li>Edit the Application in the Argo CD UI to change targetRevision</li> <li>Or update your Git manifest and let Argo CD sync it</li> </ul> <p>This is a manual promotion, which gives you better control.</p> </li> <li> <p>Automate via CI/CD     Use a script or pipeline step to:</p> <ul> <li>Bump Chart.yaml</li> <li>Push to ChartMuseum</li> <li>Update your Argo CD Application manifest (targetRevision)</li> <li>Commit and push to Git</li> </ul> </li> </ol> <p>Argo CD sees the Git change and syncs automatically.</p> <p>For images we already setup argocd-image-updater to automatically update the image tag in the values.yaml file. </p> <p>To check for updates either:</p> <ul> <li>Check ArgoCD UI</li> <li><code>kubectl logs -n argocd pod/argocd-image-updater-665f95946-94v6x</code></li> <li><code>kubectl get application my-argocd-app-with-chart -o yaml | less</code></li> </ul>"},{"location":"automation/taskfile/","title":"Task Runner Automation","text":"<p>This document explains how the Task runner is used to automate common operations in the ArgoCD demonstration project.</p>"},{"location":"automation/taskfile/#overview","title":"Overview","text":"<p>The project uses Task (a task runner / build tool) to automate common operations and provide a consistent interface for working with the project. Task is a modern alternative to Make, with a focus on simplicity and ease of use.</p>"},{"location":"automation/taskfile/#taskfile-structure","title":"Taskfile Structure","text":"<p>The main task definitions are stored in <code>Taskfile.yml</code> at the root of the project:</p> <p>Available tasks:</p> Task Description argocd-init-passwd This is a command to initialize argocd password. Use admin as username bootstrap-app0 Bootstrap argocd application using app0 cleanup Deletes the terraform resources and the kind cluster create-cluster Create a Kind cluster if it doesn't already exist default Default command del-ssh-key Delete ssh key for argocd-image-updater dev Spin up teh complete dev cluster docs \ud83c\udf10 Serve docs locally -&gt; http://127.0.0.1:8000/argocd-demo/ expose-kubeconfig Expose cluster kubeconfig helm-add-argocd Add argocd helm repo (image updater chart lives here) port-forward-argocd Forward the Argo CD server UI to localhost:8080 ports This is a command to list ports in use ssh-keygen Generate ssh key for argocd-image-updater tf-apply Install or update Argo CD resources using Terraform tf-lint Makes sure tf files arecorrectly formatted before running tf commands <p>Additional task files, such as <code>Taskfile.gitflow.yml</code>, provide repeatable gitflow functionality.</p> <p>Available gitflow tasks:</p> Task Description argocd-init-passwd This is a command to initialize argocd password. Use admin as username bootstrap-app0 Bootstrap argocd application using app0 cleanup Deletes the terraform resources and the kind cluster create-cluster Create a Kind cluster if it doesn't already exist default Default command del-ssh-key Delete ssh key for argocd-image-updater dev Spin up teh complete dev cluster docs \ud83c\udf10 Serve docs locally -&gt; http://127.0.0.1:8000/argocd-demo/ expose-kubeconfig Expose cluster kubeconfig helm-add-argocd Add argocd helm repo (image updater chart lives here) port-forward-argocd Forward the Argo CD server UI to localhost:8080 ports This is a command to list ports in use ssh-keygen Generate ssh key for argocd-image-updater tf-apply Install or update Argo CD resources using Terraform tf-lint Makes sure tf files arecorrectly formatted before running tf commands"},{"location":"automation/taskfile/#task-execution","title":"Task Execution","text":"<p>Tasks are executed using the <code>task</code> command:</p> <pre><code># Run the default task\ntask\n\n# Run a specific task\ntask create-cluster\n\n# Run a task with arguments\ntask feature-start my-new-feature\n</code></pre>"},{"location":"automation/taskfile/#extending-task-automation","title":"Extending Task Automation","text":"<p>To add new tasks:</p> <ol> <li>Edit the appropriate Taskfile (e.g., <code>Taskfile.yml</code>)</li> <li>Define the new task with a description and commands</li> <li>Add any dependencies or variables needed</li> <li>Save the file and run <code>task --list-all</code> to verify</li> </ol> <p>Example of adding a new task:</p> <pre><code>deploy-app:\n  desc: \"Deploy a sample application\"\n  deps:\n    - install-argocd\n  cmds:\n    - kubectl apply -f 0-application.yaml\n    - kubectl apply -f 1-application.yaml\n</code></pre>"},{"location":"automation/taskfile/#best-practices","title":"Best Practices","text":"<ol> <li>Descriptive Names: Use clear, descriptive names for tasks</li> <li>Add Descriptions: Include a description for each task</li> <li>Use Dependencies: Define task dependencies explicitly</li> <li>Idempotent Commands: Make tasks safe to run multiple times</li> <li>Status Checks: Use status checks to avoid unnecessary work</li> <li>Organize Tasks: Group related tasks in separate Taskfiles</li> <li>Document Tasks: Include task documentation in project docs</li> </ol>"},{"location":"automation/taskfile/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>Architecture Overview</li> </ul>"},{"location":"infrastructure/terraform/","title":"Terraform Configuration","text":"<p>This document details the Terraform infrastructure as code implementation used to provision and manage ArgoCD in the Kubernetes cluster.</p>"},{"location":"infrastructure/terraform/#overview","title":"Overview","text":"<p>Terraform is used in this project to provide a reproducible, version-controlled approach to infrastructure provisioning. The primary focus is on installing and configuring ArgoCD in the Kubernetes cluster.</p>"},{"location":"infrastructure/terraform/#argocd-installation","title":"ArgoCD Installation","text":"<p>ArgoCD is installed using the official Helm chart through Terraform:</p> <pre><code># From 1-argocd.tf\nresource \"helm_release\" \"argocd\" {\n    name = \"argocd\"\n    repository = \"https://argoproj.github.io/argo-helm\"\n    chart = \"argo-cd\"\n    version = \"3.35.4\"\n    namespace = \"argocd\"\n    create_namespace = true\n    values = [file(\"values/argocd-values.yaml\")]\n}\n</code></pre> <p>This approach offers several benefits: - Version Pinning: Specific ArgoCD version (3.35.4) ensures consistency - Namespace Management: Creates the ArgoCD namespace if it doesn't exist - Configuration as Code: Uses values file for customization - Reproducibility: Same installation can be reproduced on any cluster</p>"},{"location":"infrastructure/terraform/#helm-chart-values","title":"Helm Chart Values","text":"<p>The ArgoCD Helm chart is configured using values specified in <code>values/argocd-values.yaml</code>. Key configurations include:</p> <ul> <li>Server configuration</li> <li>RBAC settings</li> <li>Resource limits</li> <li>High availability settings (disabled for demo)</li> <li>UI customization</li> <li>Authentication settings</li> </ul>"},{"location":"infrastructure/terraform/#execution-flow","title":"Execution Flow","text":"<p>When running <code>task install-argocd</code>, the following happens:</p> <ol> <li>Task runner executes commands in the terraform directory</li> <li>Terraform initializes providers and modules</li> <li>Terraform applies the configuration:</li> <li>Creates the ArgoCD namespace</li> <li>Installs ArgoCD using the Helm chart</li> <li>Applies custom configuration values</li> </ol>"},{"location":"infrastructure/terraform/#alternative-approaches","title":"Alternative Approaches","text":"<p>While Terraform is used in this project, the documentation notes alternative approaches that could be used:</p> <pre><code># Direct kubectl approach\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n\n# Direct Helm approach\nhelm repo add argocd https://argoproj.github.io/argo-helm\nhelm repo update\nhelm install argocd -n argocd --create-namespace argocd/argo-cd --version 3.35.4\n</code></pre> <p>Terraform was chosen for this project because: - It provides better dependency management - Configuration is more maintainable as code - It integrates well with the GitOps workflow - It allows for more complex provisioning logic</p>"},{"location":"infrastructure/terraform/#best-practices-implemented","title":"Best Practices Implemented","text":"<ol> <li>Version Pinning: Specific versions for providers and charts</li> <li>Modular Structure: Separate files for different concerns</li> <li>Value Externalization: Configuration values in separate files</li> <li>Resource Naming: Consistent naming conventions</li> <li>State Management: Proper handling of Terraform state</li> </ol>"},{"location":"infrastructure/terraform/#extending-the-infrastructure","title":"Extending the Infrastructure","text":"<p>To extend the infrastructure:</p> <ol> <li>Add new <code>.tf</code> files for additional components</li> <li>Update or create values files for configuration</li> <li>Apply changes using <code>terraform apply</code> or through the task runner</li> </ol>"},{"location":"infrastructure/terraform/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>System Architecture</li> <li>Getting Started</li> </ul>"},{"location":"quickstart/getting-started/","title":"Getting Started with ArgoCD Demo","text":"<p>This guide will help you quickly get started with this ArgoCD demonstration project. Follow these steps to set up your environment and deploy your first application.</p>"},{"location":"quickstart/getting-started/#overview","title":"Overview","text":"<p>This project demonstrates GitOps principles using ArgoCD on a Kubernetes cluster. The setup includes:</p> <ul> <li>A local Kubernetes cluster using Kind</li> <li>ArgoCD installed via Terraform</li> <li>Sample applications deployed through ArgoCD</li> <li>Helm charts for application packaging</li> <li>Task automation for common operations</li> </ul>"},{"location":"quickstart/getting-started/#quick-setup","title":"Quick Setup","text":"<p>To create the local Kubernetes cluster and deploy Argo CD, simply run:</p> <p><pre><code>task ssh-keygen \n</code></pre> Then copy the private key to the <code>0-repo-secret.yaml</code> file for argocd-image-updater. Then copy the public key to the deploy key section in the github repo. Then run the next command. </p> <pre><code>task dev\n</code></pre> <p>This single command will:  1. Create a local Kind cluster (if it's not already running).  2. Deploy Argo CD using the Terraform configuration.  3. Bootstrap argocd application using 1-sealed-secrets.yaml (this is generated by kubeseal and is the secret argocd will use to update the image in the github repo).  4. Bootstrap argocd application using 0-application.yaml (this is the application.yaml file with app of apps pattern, TF and helm).  5. Expose cluster kubeconfig for tools like lens  6. Add argocd helm repo</p> <p>Then run:</p> <pre><code>task port-fwd-argocd\n</code></pre> <p>You can now access the Argo CD UI at http://localhost:8080 with username <code>admin</code> and for the password run(in a seperate terminal):</p> <pre><code>task argocd-init-passwd\n</code></pre> <p>Then in a seperate terminal window run:</p> <pre><code>task helm-package-push\n</code></pre> <p>Then run:</p> <pre><code>task docs # This will serve the docs locally at http://127.0.0.1:8000/argocd-demo/\n</code></pre> <p>Use the following command to clean up the cluster and terraform resources:</p> <p><pre><code>task cleanup\n</code></pre> This will delete the cluster and terraform resources.</p>"},{"location":"quickstart/getting-started/#other-available-commands","title":"Other Available Commands","text":"<p>To see a full list of all available tasks, run <code>task --list-all</code></p>"},{"location":"quickstart/getting-started/#git-workflow-with-git-flow","title":"Git Workflow with Git Flow","text":"<p>The <code>Taskfile.gitflow.yml</code> provides a structured Git workflow using Git Flow. This helps in managing features, releases, and hotfixes in a standardized way.</p> <p>use <code>task -t Taskfile.gitflow.yml --list-all</code> to see all gitflow tasks</p>"},{"location":"quickstart/getting-started/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during setup:</p> <ol> <li>Ensure all prerequisites are installed</li> <li>Check the ArgoCD documentation for troubleshooting tips</li> <li>Review the ArgoCD Overview for configuration details</li> </ol>"},{"location":"quickstart/prerequisites/","title":"Prerequisites","text":"<p>This project uses Devbox to manage the development environment. Devbox provides a consistent, isolated environment with all the necessary tools pre-installed.</p>"},{"location":"quickstart/prerequisites/#system-requirements","title":"System Requirements","text":"<ul> <li>CPU: 2+ cores recommended</li> <li>Memory: 4GB+ RAM recommended</li> <li>Disk Space: 10GB+ free space</li> <li>Operating System: Linux, macOS, or Windows with WSL2</li> </ul>"},{"location":"quickstart/prerequisites/#network-requirements","title":"Network Requirements","text":"<ul> <li>Outbound internet access for downloading container images</li> <li>Available local ports:</li> <li>8080: ArgoCD UI</li> <li>6443: Kubernetes API server</li> </ul>"},{"location":"quickstart/prerequisites/#required-tools","title":"Required Tools","text":"<ol> <li>install Docker</li> <li>Follow the installation instructions for your operating system</li> </ol> <p>The rest of the tools are installed using devbox</p> <ol> <li>Install Devbox</li> <li> <p>Follow the installation instructions for your operating system</p> </li> <li> <p>Clone the Repository <pre><code>git clone https://github.com/sean-njela/argocd-demo.git\ncd argocd-demo\n</code></pre></p> </li> <li> <p>Start the Devbox Environment and poetry environment <pre><code>devbox shell # Start the devbox environment\npoetry install # Install dependencies\npoetry env activate # use the output to activate the poetry environment\nmkdocs serve # Start the mkdocs server http://127.0.0.1:8000/argocd-demo/\n</code></pre></p> <p>Note - The first time you run <code>devbox shell</code>, it will take a few minutes to install the necessary tools. But after that it will be much faster.</p> </li> </ol> <p>This concludes all the prerequisites for this project. (Yes, really.)</p>"},{"location":"quickstart/prerequisites/#optional-tools","title":"Optional Tools","text":"<p>These tools are not required for the project to run but can enhance your experience. They are also included in the devbox environment:</p> <ul> <li>k9s: Terminal-based UI for Kubernetes</li> <li>Lens: Kubernetes IDE for simplified cluster management</li> <li>kubectx/kubens: Tools for switching between contexts and namespaces</li> </ul>"},{"location":"quickstart/prerequisites/#next-steps","title":"Next Steps","text":"<p>Once you've confirmed all prerequisites are met, proceed to the Getting Started to set up the ArgoCD demonstration environment.</p>"}]}