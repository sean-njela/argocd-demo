{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArgoCD DevOps Portfolio Project","text":"<p>Professional GitOps Implementation with ArgoCD</p> <p>Portfolio Project</p> <p>This is a professional portfolio project showcasing DevOps expertise with ArgoCD, Kubernetes, Terraform, and GitOps principles.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project demonstrates a complete GitOps workflow using ArgoCD to manage Kubernetes applications. It showcases professional DevOps practices including:</p> <ul> <li>Infrastructure as Code with Terraform for ArgoCD installation</li> <li>GitOps Workflow with declarative application configurations</li> <li>Kubernetes Management using Kind for local development</li> <li>Helm Charts for package management and deployment</li> <li>Multi-Environment Support with environment-specific configurations</li> <li>Task Automation for common operations</li> <li>Comprehensive Documentation for maintainability</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Declarative Application Deployment: Applications defined as code in Git</li> <li>Automated Synchronization: Changes in Git automatically applied to the cluster</li> <li>Environment Management: Separate configurations for different environments</li> <li>Terraform Integration: Infrastructure provisioning with code</li> <li>Helm Chart Management: Standardized application packaging</li> <li>Local Development: Kind cluster for local testing</li> <li>Task Automation: Streamlined workflows with Task runner</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with this project:</p> <ol> <li>Check the Prerequisites for required tools</li> <li>Follow the Installation Guide to set up the environment</li> <li>Explore the Architecture Overview to understand the system design</li> </ol>"},{"location":"disclaimer/","title":"Disclaimer","text":"<p>Portfolio Project</p> <p>This is a personal portfolio project created to demonstrate DevOps skills and knowledge to potential employers and recruiters.</p>"},{"location":"disclaimer/#project-purpose","title":"Project Purpose","text":"<p>This ArgoCD demonstration project was created with the following purposes:</p> <ol> <li>Showcase Technical Skills: To demonstrate practical knowledge of GitOps, Kubernetes, ArgoCD, Terraform, and related technologies</li> <li>Portfolio Development: To serve as a concrete example of DevOps best practices for professional portfolio</li> <li>Learning Resource: To document the implementation of ArgoCD in a structured, educational manner</li> </ol>"},{"location":"disclaimer/#not-for-production-use","title":"Not For Production Use","text":"<p>While this project implements many best practices and security considerations, it is designed primarily as a demonstration and learning tool. Some considerations for production environments may include:</p> <ul> <li>Additional security hardening</li> <li>High availability configurations</li> <li>Backup and disaster recovery procedures</li> <li>Monitoring and alerting setup</li> <li>Performance optimization for scale</li> </ul>"},{"location":"disclaimer/#skills-demonstrated","title":"Skills Demonstrated","text":"<p>This project demonstrates proficiency in:</p> <ul> <li>GitOps Principles: Declarative infrastructure and application definitions</li> <li>Kubernetes Administration: Cluster setup, application deployment, and management</li> <li>Infrastructure as Code: Using Terraform to provision infrastructure</li> <li>CI/CD Practices: Automated deployment pipelines</li> <li>Configuration Management: Managing application configurations across environments</li> <li>Documentation: Creating comprehensive technical documentation</li> </ul>"},{"location":"disclaimer/#contact-information","title":"Contact Information","text":"<p>For questions, feedback, or professional inquiries related to this project, please contact:</p> <ul> <li>GitHub: sean-njela</li> <li>LinkedIn: Sean Njela</li> </ul> <p>This project is licensed under the terms of the LICENSE file included in the repository.</p>"},{"location":"architecture/overview/","title":"System Architecture Overview","text":"<p>This document provides a high-level overview of the ArgoCD demonstration project architecture, explaining how the various components interact to implement GitOps principles.</p>"},{"location":"architecture/overview/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TD\n    subgraph \"Git Repository\"\n        A[Application Manifests]\n        B[Helm Charts]\n        C[Infrastructure Code]\n    end\n\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"ArgoCD\"\n            D[ArgoCD Server]\n            E[ArgoCD Repo Server]\n            F[ArgoCD Application Controller]\n            G[ArgoCD Redis]\n            H[ArgoCD Dex Server]\n        end\n\n        subgraph \"Applications\"\n            I[App 1]\n            J[App 2]\n        end\n    end\n\n    subgraph \"Infrastructure\"\n        K[Terraform]\n        L[Kind Cluster]\n    end\n\n    A --&gt;|Source of Truth| E\n    B --&gt;|Chart Templates| E\n    E --&gt;|Manifests| F\n    F --&gt;|Reconciles| I\n    F --&gt;|Reconciles| J\n    K --&gt;|Provisions| D\n    K --&gt;|Provisions| E\n    K --&gt;|Provisions| F\n    K --&gt;|Provisions| G\n    K --&gt;|Provisions| H\n    L --&gt;|Hosts| D</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#git-repository","title":"Git Repository","text":"<p>The Git repository serves as the single source of truth for the entire system, containing:</p> <ul> <li>Application Manifests: Kubernetes manifests defining the desired state of applications</li> <li>Helm Charts: Templated application packages for consistent deployment</li> <li>Infrastructure Code: Terraform configurations for provisioning infrastructure</li> </ul>"},{"location":"architecture/overview/#argocd","title":"ArgoCD","text":"<p>ArgoCD is the GitOps continuous delivery tool that ensures the cluster state matches the desired state defined in Git:</p> <ul> <li>ArgoCD Server: Provides the API and UI for managing applications</li> <li>Repo Server: Responsible for cloning Git repositories and generating Kubernetes manifests</li> <li>Application Controller: Monitors running applications and compares their state to the desired state</li> <li>Redis: Caches repository information and serves as a shared cache</li> <li>Dex Server: Optional component for SSO authentication</li> </ul>"},{"location":"architecture/overview/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<p>The Kubernetes cluster is created using Kind (Kubernetes in Docker) for local development:</p> <ul> <li>Control Plane: Manages the cluster state and API</li> <li>Worker Nodes: Run the application workloads</li> <li>Namespaces: Logical separation of applications and components</li> </ul>"},{"location":"architecture/overview/#infrastructure-management","title":"Infrastructure Management","text":"<ul> <li>Terraform: Provisions and configures ArgoCD in a reproducible manner</li> <li>Task Runner: Automates common operations and workflows</li> </ul>"},{"location":"architecture/overview/#workflow","title":"Workflow","text":"<ol> <li>Development: Changes are made to application code or configuration in Git</li> <li>Commit &amp; Push: Changes are committed and pushed to the Git repository</li> <li>Detection: ArgoCD detects changes in the Git repository</li> <li>Comparison: ArgoCD compares the desired state with the current state</li> <li>Reconciliation: ArgoCD applies changes to bring the cluster to the desired state</li> <li>Monitoring: ArgoCD continuously monitors for drift between desired and actual state</li> </ol>"},{"location":"architecture/overview/#environment-structure","title":"Environment Structure","text":"<p>The project supports multiple environments through directory structure:</p> <pre><code>environments/\n\u251c\u2500\u2500 dev/\n\u2502   \u251c\u2500\u2500 apps/\n\u2502   \u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u2514\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 helm/\n\u2502       \u2514\u2500\u2500 myargoapp-chart/\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Each environment contains: - Application-specific configurations - Environment-specific values - Helm charts for templated applications</p>"},{"location":"architecture/overview/#security-considerations","title":"Security Considerations","text":"<ul> <li>RBAC: Role-Based Access Control for ArgoCD and Kubernetes resources</li> <li>Secure Defaults: ArgoCD is configured with secure default settings</li> <li>Least Privilege: Components operate with minimal required permissions</li> <li>Secrets Management: Sensitive information is properly managed</li> </ul>"},{"location":"architecture/overview/#scalability","title":"Scalability","text":"<p>While this demonstration uses a single-node Kind cluster, the architecture is designed to be scalable:</p> <ul> <li>Horizontal Scaling: Applications can be scaled horizontally</li> <li>Multi-Environment: Structure supports multiple environments (dev, staging, prod)</li> <li>Multi-Cluster: ArgoCD can manage multiple Kubernetes clusters</li> </ul>"},{"location":"architecture/overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>Infrastructure with Terraform</li> <li>ArgoCD Applications</li> <li>ArgoCD Overview</li> </ul>"},{"location":"argocd/applications/","title":"Application Deployment with ArgoCD","text":"<p>This document explains how applications are defined, deployed, and managed using ArgoCD in this project.</p>"},{"location":"argocd/applications/#application-definition","title":"Application Definition","text":"<p>In ArgoCD, applications are defined using the <code>Application</code> custom resource. This project includes two sample applications:</p> <ol> <li>A Helm-based application (<code>0-application.yaml</code>)</li> <li>A Kubernetes manifest-based application (<code>1-application.yaml</code>)</li> </ol>"},{"location":"argocd/applications/#example-application-definition","title":"Example Application Definition","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myargoapp-0\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/dev/helm/myargoapp-chart\n    helm:\n      valueFiles:\n        - values.yaml\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp-0\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre>"},{"location":"argocd/applications/#key-components-of-an-application-definition","title":"Key Components of an Application Definition","text":""},{"location":"argocd/applications/#metadata","title":"Metadata","text":"<ul> <li>name: Unique identifier for the application</li> <li>namespace: The namespace where the ArgoCD Application resource is created (typically <code>argocd</code>)</li> </ul>"},{"location":"argocd/applications/#spec","title":"Spec","text":"<ul> <li>project: The ArgoCD project this application belongs to (default or custom)</li> <li>source: Where to find the application manifests:</li> <li>repoURL: Git repository URL</li> <li>targetRevision: Git revision (branch, tag, commit)</li> <li>path: Path within the repository</li> <li>helm: Helm-specific configuration (if using Helm)</li> <li>destination: Where to deploy the application:</li> <li>server: Target Kubernetes cluster</li> <li>namespace: Target namespace for the application</li> <li>syncPolicy: How ArgoCD should handle synchronization:</li> <li>automated: Settings for automatic synchronization</li> <li>syncOptions: Additional sync options</li> </ul>"},{"location":"argocd/applications/#application-types","title":"Application Types","text":""},{"location":"argocd/applications/#helm-based-applications","title":"Helm-Based Applications","text":"<p>For applications packaged as Helm charts:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/helm/myargoapp-chart\n  helm:\n    valueFiles:\n      - values.yaml\n    parameters:\n      - name: replicaCount\n        value: \"2\"\n</code></pre>"},{"location":"argocd/applications/#kubernetes-manifest-applications","title":"Kubernetes Manifest Applications","text":"<p>For applications defined with plain Kubernetes manifests:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/apps/myapp\n  directory:\n    recurse: true\n    jsonnet: {}\n</code></pre>"},{"location":"argocd/applications/#kustomize-applications","title":"Kustomize Applications","text":"<p>For applications using Kustomize:</p> <pre><code>source:\n  repoURL: https://github.com/sean-njela/argocd-demo.git\n  targetRevision: HEAD\n  path: environments/dev/kustomize\n  kustomize:\n    namePrefix: dev-\n    images:\n      - myapp:latest\n</code></pre>"},{"location":"argocd/applications/#sync-policies","title":"Sync Policies","text":""},{"location":"argocd/applications/#manual-sync","title":"Manual Sync","text":"<p>Applications can be configured for manual synchronization:</p> <pre><code>syncPolicy: {}  # No automated sync\n</code></pre> <p>With manual sync, changes must be applied explicitly through the UI or CLI.</p>"},{"location":"argocd/applications/#automated-sync","title":"Automated Sync","text":"<p>For automatic synchronization when changes are detected:</p> <pre><code>syncPolicy:\n  automated:\n    prune: true    # Remove resources that no longer exist in Git\n    selfHeal: true # Revert manual changes made to the cluster\n</code></pre>"},{"location":"argocd/applications/#sync-options","title":"Sync Options","text":"<p>Additional synchronization options:</p> <pre><code>syncPolicy:\n  syncOptions:\n    - CreateNamespace=true    # Create namespace if it doesn't exist\n    - PruneLast=true          # Remove resources last during sync\n    - ApplyOutOfSyncOnly=true # Only apply resources that are out of sync\n</code></pre>"},{"location":"argocd/applications/#application-health","title":"Application Health","text":"<p>ArgoCD monitors the health of deployed applications based on:</p> <ol> <li>Kubernetes resource status</li> <li>Custom health checks</li> <li>Resource-specific health assessments (e.g., Deployments, StatefulSets)</li> </ol> <p>Health status is displayed in the UI and available via the API and CLI.</p>"},{"location":"argocd/applications/#deploying-applications","title":"Deploying Applications","text":""},{"location":"argocd/applications/#using-kubectl","title":"Using kubectl","text":"<pre><code># Apply the Application manifest\nkubectl apply -f 0-application.yaml\n</code></pre>"},{"location":"argocd/applications/#using-argocd-cli","title":"Using ArgoCD CLI","text":"<pre><code># Create application from a manifest\nargocd app create -f 0-application.yaml\n\n# Create application with CLI parameters\nargocd app create myapp \\\n  --repo https://github.com/sean-njela/argocd-demo.git \\\n  --path environments/dev/apps/myapp \\\n  --dest-server https://kubernetes.default.svc \\\n  --dest-namespace myapp\n</code></pre>"},{"location":"argocd/applications/#using-the-argocd-ui","title":"Using the ArgoCD UI","text":"<ol> <li>Navigate to the ArgoCD UI at http://localhost:8080</li> <li>Click \"New App\" in the top left</li> <li>Fill in the application details</li> <li>Click \"Create\"</li> </ol>"},{"location":"argocd/applications/#managing-applications","title":"Managing Applications","text":""},{"location":"argocd/applications/#viewing-application-status","title":"Viewing Application Status","text":"<pre><code># Using kubectl\nkubectl get applications -n argocd\nkubectl describe application myapp -n argocd\n\n# Using ArgoCD CLI\nargocd app get myapp\nargocd app list\n</code></pre>"},{"location":"argocd/applications/#syncing-applications","title":"Syncing Applications","text":"<pre><code># Using ArgoCD CLI\nargocd app sync myapp\n\n# Force sync (overwrite live state)\nargocd app sync myapp --force\n</code></pre>"},{"location":"argocd/applications/#deleting-applications","title":"Deleting Applications","text":"<pre><code># Using kubectl\nkubectl delete application myapp -n argocd\n\n# Using ArgoCD CLI\nargocd app delete myapp\n</code></pre>"},{"location":"argocd/applications/#best-practices","title":"Best Practices","text":"<ol> <li>Use Declarative Definitions: Store Application manifests in Git</li> <li>Environment Separation: Use separate paths or values for different environments</li> <li>Resource Limits: Set appropriate CPU and memory limits</li> <li>Health Checks: Implement proper readiness and liveness probes</li> <li>Namespace Isolation: Use separate namespaces for different applications</li> <li>Sync Windows: Configure sync windows for controlled updates</li> <li>Progressive Delivery: Use canary or blue-green deployments for critical applications</li> </ol>"},{"location":"argocd/applications/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>Environment Management</li> <li>System Architecture</li> <li>Helm Chart Structure</li> </ul>"},{"location":"argocd/environments/","title":"Environment Management with ArgoCD","text":"<p>This document explains how multiple environments are managed in this ArgoCD project using GitOps principles.</p>"},{"location":"argocd/environments/#environment-structure","title":"Environment Structure","text":"<p>The project uses a directory-based approach to manage different environments:</p> <pre><code>environments/\n\u251c\u2500\u2500 dev/                  # Development environment\n\u2502   \u251c\u2500\u2500 apps/             # Kubernetes manifest applications\n\u2502   \u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u2514\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 helm/             # Helm chart applications\n\u2502       \u2514\u2500\u2500 myargoapp-chart/\n\u2514\u2500\u2500 README.md             # Environment documentation\n</code></pre> <p>This structure allows for: - Clear separation between environments - Environment-specific configurations - Consistent application structure across environments - Easy addition of new environments (staging, production, etc.)</p>"},{"location":"argocd/environments/#environment-configuration","title":"Environment Configuration","text":""},{"location":"argocd/environments/#development-environment","title":"Development Environment","text":"<p>The development environment (<code>dev/</code>) is configured for:</p> <ul> <li>Local development using Kind</li> <li>Rapid iteration and testing</li> <li>Minimal resource requirements</li> <li>Debug-friendly settings</li> <li>Automated synchronization</li> </ul>"},{"location":"argocd/environments/#adding-new-environments","title":"Adding New Environments","text":"<p>To add new environments (e.g., staging, production):</p> <ol> <li> <p>Create a new directory under <code>environments/</code>:    <pre><code>mkdir -p environments/staging/apps environments/staging/helm\n</code></pre></p> </li> <li> <p>Copy and modify the base configurations:    <pre><code>cp -r environments/dev/apps/app1 environments/staging/apps/\n</code></pre></p> </li> <li> <p>Update environment-specific values:</p> </li> <li>Resource limits and requests</li> <li>Replica counts</li> <li>Configuration parameters</li> <li> <p>External service endpoints</p> </li> <li> <p>Create environment-specific ArgoCD Applications:    <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myapp-staging\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/staging/apps/app1\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp-staging\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre></p> </li> </ol>"},{"location":"argocd/environments/#environment-isolation","title":"Environment Isolation","text":"<p>Each environment is isolated through:</p> <ol> <li>Namespace Separation: Each environment uses dedicated namespaces</li> <li>Configuration Separation: Environment-specific configurations</li> <li>Resource Quotas: Limits on CPU, memory, and other resources</li> <li>Network Policies: Controlled network access between environments</li> <li>RBAC: Role-based access control for different environments</li> </ol>"},{"location":"argocd/environments/#environment-specific-values","title":"Environment-Specific Values","text":""},{"location":"argocd/environments/#helm-values","title":"Helm Values","text":"<p>For Helm-based applications, environment-specific values are managed through values files:</p> <pre><code># environments/dev/helm/myargoapp-chart/values.yaml\nreplicaCount: 1\nresources:\n  limits:\n    cpu: 100m\n    memory: 128Mi\n  requests:\n    cpu: 50m\n    memory: 64Mi\n</code></pre> <pre><code># environments/staging/helm/myargoapp-chart/values.yaml\nreplicaCount: 2\nresources:\n  limits:\n    cpu: 200m\n    memory: 256Mi\n  requests:\n    cpu: 100m\n    memory: 128Mi\n</code></pre>"},{"location":"argocd/environments/#kustomize-overlays","title":"Kustomize Overlays","text":"<p>For applications using Kustomize, environment-specific configurations are managed through overlays:</p> <pre><code>apps/myapp/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service.yaml\n\u2502   \u2514\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 overlays/\n\u2502   \u251c\u2500\u2500 dev/\n\u2502   \u2502   \u251c\u2500\u2500 kustomization.yaml\n\u2502   \u2502   \u2514\u2500\u2500 patch.yaml\n\u2502   \u2514\u2500\u2500 staging/\n\u2502       \u251c\u2500\u2500 kustomization.yaml\n\u2502       \u2514\u2500\u2500 patch.yaml\n</code></pre>"},{"location":"argocd/environments/#promotion-between-environments","title":"Promotion Between Environments","text":"<p>The project supports promoting applications between environments:</p> <ol> <li>Testing in Development: Applications are first deployed to the development environment</li> <li>Validation: Automated and manual testing verifies the application</li> <li>Promotion: Changes are merged to the staging branch</li> <li>Staging Deployment: ArgoCD automatically deploys to staging</li> <li>Production Approval: Changes are approved for production</li> <li>Production Deployment: ArgoCD deploys to production</li> </ol>"},{"location":"argocd/environments/#environment-specific-sync-policies","title":"Environment-Specific Sync Policies","text":"<p>Different environments can have different sync policies:</p> <ul> <li> <p>Development: Automated sync with self-healing   <pre><code>syncPolicy:\n  automated:\n    prune: true\n    selfHeal: true\n</code></pre></p> </li> <li> <p>Staging: Automated sync with manual approval   <pre><code>syncPolicy:\n  automated:\n    prune: true\n    selfHeal: true\n  syncOptions:\n    - PruneLast=true\n</code></pre></p> </li> <li> <p>Production: Manual sync with sync windows   <pre><code>syncPolicy:\n  syncOptions:\n    - PruneLast=true\n    - ApplyOutOfSyncOnly=true\n</code></pre></p> </li> </ul>"},{"location":"argocd/environments/#environment-variables-and-secrets","title":"Environment Variables and Secrets","text":"<p>Environment-specific secrets and variables are managed through:</p> <ol> <li>Kubernetes Secrets: For sensitive information</li> <li>ConfigMaps: For non-sensitive configuration</li> <li>External Secret Management: Integration with tools like HashiCorp Vault (in production)</li> </ol>"},{"location":"argocd/environments/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent Structure: Maintain the same structure across environments</li> <li>Minimal Differences: Keep environment-specific changes to a minimum</li> <li>Documentation: Document the purpose and configuration of each environment</li> <li>Testing: Test changes in lower environments before promotion</li> <li>Access Control: Implement appropriate access controls for each environment</li> <li>Monitoring: Set up environment-specific monitoring and alerts</li> <li>Disaster Recovery: Implement backup and recovery procedures for each environment</li> </ol>"},{"location":"argocd/environments/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>Application Deployment</li> <li>System Architecture</li> <li>Infrastructure with Terraform</li> </ul>"},{"location":"argocd/image-updater/","title":"Argo CD Image Updater","text":""},{"location":"argocd/image-updater/#overview","title":"Overview","text":"<p>Argo CD Image Updater is a tool that automatically updates container images in your Kubernetes cluster based on the latest available versions in your container registry. It helps keep your applications up to date with the latest security patches and bug fixes.</p> <p>There are two write-back methods supported by Argo CD Image Updater, which define where the image update changes are applied:</p>"},{"location":"argocd/image-updater/#argo-cd-image-updater-write-back-methods","title":"\ud83d\udd04 Argo CD Image Updater: Write-Back Methods","text":"<p>There are two primary write-back methods:</p>"},{"location":"argocd/image-updater/#1-git-write-back-gitops-mode","title":"1. Git Write-Back (GitOps Mode) \u2705","text":"<p>This is the default and recommended method, fully aligned with GitOps principles.</p>"},{"location":"argocd/image-updater/#how-it-works","title":"\ud83d\udee0 How it works:","text":"<ul> <li>Image Updater detects a new image version.</li> <li>It modifies the Kubernetes manifest or Helm values file in the Git repository.</li> <li>Commits and pushes the change to Git.</li> <li>Argo CD (which continuously watches Git) detects the change and applies it to the cluster.</li> </ul>"},{"location":"argocd/image-updater/#pros","title":"\u2705 Pros:","text":"<ul> <li>Git remains the source of truth.</li> <li>Full audit history via Git commits.</li> <li>Works well with review processes, PRs, and version control tools.</li> <li>Clean separation of change and deployment.</li> </ul>"},{"location":"argocd/image-updater/#requirements","title":"\ud83d\udd10 Requirements:","text":"<ul> <li>Access to Git repo with push privileges (via SSH key or token).</li> <li>Correct annotations for image list, strategy, and write-back config.</li> </ul>"},{"location":"argocd/image-updater/#2-direct-cluster-update-argo-cd-api-mode","title":"2. Direct Cluster Update (Argo CD API Mode) \u26a0\ufe0f","text":"<p>This is a more imperative approach, where the image updater bypasses Git and directly patches the live application in the Kubernetes cluster via the Argo CD API.</p>"},{"location":"argocd/image-updater/#how-it-works_1","title":"\ud83d\udee0 How it works:","text":"<ul> <li>Detects a new image version.</li> <li>Uses the Argo CD API to patch the image parameter of the running app.</li> <li>Change is applied directly to the live Kubernetes app (stored in Argo CD\u2019s state), but not recorded in Git.</li> </ul>"},{"location":"argocd/image-updater/#pros_1","title":"\u26a0\ufe0f Pros:","text":"<ul> <li>Fastest way to update running workloads.</li> <li>Doesn\u2019t require Git access.</li> </ul>"},{"location":"argocd/image-updater/#cons","title":"\u274c Cons:","text":"<ul> <li>Violates GitOps principles \u2014 Git is no longer the single source of truth.</li> <li>Changes will be overwritten if Argo CD auto-syncs from Git later.</li> <li>No Git commit/audit trail of what was deployed.</li> </ul>"},{"location":"argocd/image-updater/#use-case","title":"\u2699\ufe0f Use case:","text":"<ul> <li>Temporary patches or urgent updates where Git isn\u2019t accessible.</li> <li>Testing environments.</li> </ul>"},{"location":"argocd/image-updater/#summary-table","title":"\ud83d\udcdd Summary Table","text":"Method Description GitOps-Friendly Persisted in Git Recommended For Git Write-Back Updates manifests in Git \u2705 Yes \u2705 Yes Production, CI/CD Direct Cluster Updates Argo CD app live via API \u274c No \u274c No Dev/test, emergencies"},{"location":"argocd/image-updater/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>Specify the write-back method via annotations or config file:</p> <pre><code>argocd-image-updater.argoproj.io/write-back-method: git\n</code></pre> <p>or</p> <pre><code>argocd-image-updater.argoproj.io/write-back-method: argocd\n</code></pre>"},{"location":"argocd/overview/","title":"ArgoCD Overview","text":"<p>This document provides a comprehensive overview of ArgoCD as implemented in this project, explaining its components, architecture, and how it enables GitOps workflows.</p>"},{"location":"argocd/overview/#what-is-argocd","title":"What is ArgoCD?","text":"<p>ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It automates the deployment of applications to Kubernetes by keeping the cluster state in sync with configuration stored in Git repositories.</p>"},{"location":"argocd/overview/#core-principles","title":"Core Principles","text":"<p>The implementation in this project adheres to the following GitOps principles:</p> <ol> <li>Declarative Configuration: All system configurations are defined declaratively</li> <li>Version Controlled: All configurations are stored in Git</li> <li>Automated Synchronization: Changes to the desired state are automatically applied</li> <li>Self-Healing: System continuously attempts to converge to the desired state</li> <li>Observability: System state and history are observable and auditable</li> </ol>"},{"location":"argocd/overview/#argocd-architecture","title":"ArgoCD Architecture","text":"<pre><code>graph TD\n    A[API Server] --&gt; B[Repository Server]\n    A --&gt; C[Application Controller]\n    D[Redis] &lt;--&gt; A\n    D &lt;--&gt; B\n    D &lt;--&gt; C\n    E[Git Repository] &lt;-- Polls --&gt; B\n    C --&gt; F[Kubernetes API]\n    G[User] --&gt; A\n    H[Dex] &lt;-- Auth --&gt; A</code></pre>"},{"location":"argocd/overview/#components","title":"Components","text":"<ul> <li>API Server: REST API server that exposes the API consumed by the Web UI, CLI, and CI/CD systems</li> <li>Repository Server: Internal service that maintains a local cache of Git repositories</li> <li>Application Controller: Kubernetes controller that continuously monitors running applications and compares their state against the desired state</li> <li>Redis: Caches repository data and serves as a shared cache for the API server and application controller</li> <li>Dex: Optional OpenID Connect provider for SSO integration</li> </ul>"},{"location":"argocd/overview/#installation","title":"Installation","text":"<p>In this project, ArgoCD is installed using Terraform with the official Helm chart:</p> <pre><code>resource \"helm_release\" \"argocd\" {\n    name = \"argocd\"\n    repository = \"https://argoproj.github.io/argo-helm\"\n    chart = \"argo-cd\"\n    version = \"3.35.4\"\n    namespace = \"argocd\"\n    create_namespace = true\n    values = [file(\"values/argocd-values.yaml\")]\n}\n</code></pre> <p>The installation creates the following resources: - ArgoCD namespace - Core ArgoCD components (server, repo server, application controller) - RBAC resources - Service accounts - ConfigMaps for configuration - Secrets for sensitive data</p>"},{"location":"argocd/overview/#application-definition","title":"Application Definition","text":"<p>Applications in ArgoCD are defined using the <code>Application</code> custom resource:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myapp\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/dev/apps/myapp\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre> <p>Key fields in an Application definition: - source: Where the application manifests are stored - destination: The target Kubernetes cluster and namespace - syncPolicy: How ArgoCD should sync the application</p>"},{"location":"argocd/overview/#sync-strategies","title":"Sync Strategies","text":"<p>This project demonstrates several sync strategies:</p> <ol> <li>Manual Sync: Changes are applied only when manually triggered</li> <li>Automated Sync: Changes are automatically applied when detected</li> <li>Self-Healing: Drift from the desired state is automatically corrected</li> <li>Pruning: Resources no longer defined in Git are removed</li> </ol>"},{"location":"argocd/overview/#application-projects","title":"Application Projects","text":"<p>ArgoCD Projects provide a logical grouping of applications and define constraints for: - Source repositories - Destination clusters and namespaces - Permitted resource kinds - Parameters that can be set</p>"},{"location":"argocd/overview/#user-interface","title":"User Interface","text":"<p>The ArgoCD UI provides: - Application dashboard - Application details and status - Sync and rollback operations - Resource tree view - Application logs - Events and history</p> <p>Access the UI by running: <pre><code>task forward-argocd-ui\n</code></pre></p> <p>Then navigate to http://localhost:8080.</p>"},{"location":"argocd/overview/#cli-access","title":"CLI Access","text":"<p>ArgoCD provides a CLI for interacting with applications:</p> <pre><code># Login to ArgoCD\nargocd login localhost:8080\n\n# List applications\nargocd app list\n\n# Get application status\nargocd app get myapp\n\n# Sync an application\nargocd app sync myapp\n</code></pre>"},{"location":"argocd/overview/#security-considerations","title":"Security Considerations","text":"<p>This implementation includes several security best practices:</p> <ul> <li>RBAC for access control</li> <li>Secure admin password generation</li> <li>TLS for API server (in production)</li> <li>Resource constraints</li> <li>Least privilege principle</li> </ul>"},{"location":"argocd/overview/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>ArgoCD provides several ways to monitor applications:</p> <ul> <li>Health status in the UI</li> <li>Application events</li> <li>Resource tree with status</li> <li>Sync history</li> <li>Integration with Prometheus (in production)</li> </ul>"},{"location":"argocd/overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>Application Deployment</li> <li>Environment Management</li> <li>System Architecture</li> <li>Infrastructure with Terraform</li> </ul>"},{"location":"automation/taskfile/","title":"Task Runner Automation","text":"<p>This document explains how the Task runner is used to automate common operations in the ArgoCD demonstration project.</p>"},{"location":"automation/taskfile/#overview","title":"Overview","text":"<p>The project uses Task (a task runner / build tool) to automate common operations and provide a consistent interface for working with the project. Task is a modern alternative to Make, with a focus on simplicity and ease of use.</p>"},{"location":"automation/taskfile/#taskfile-structure","title":"Taskfile Structure","text":"<p>The main task definitions are stored in <code>Taskfile.yml</code> at the root of the project:</p> <pre><code>version: '3'\ntasks:\n  default:\n    desc: \"Default command\"\n    cmds:\n      - task --list-all\n\n  ports:\n    desc: \"This is a command list ports in use\"\n    cmds:\n      - ss -tunl\n\n  create-cluster:\n    desc: \"Create a Kind cluster if it doesn't already exist\"\n    cmds:\n      - kind create cluster -n argocd-demo --image kindest/node:v1.33.1\n    status:\n      - kind get clusters | grep argocd-demo\n\n  expose-kubeconfig:\n    desc: \"Expose cluster kubeconfig\"\n    cmds:\n      - cat ~/.kube/config &gt; config-kind-dev.txt\n      - echo \"Copy config-kind-dev.txt into lens to view your cluster\"\n\n  install-argocd:\n    desc: \"Install or update Argo CD using Terraform\"\n    dir: terraform\n    deps:\n      - create-cluster\n    cmds:\n      - terraform init\n      - terraform apply -auto-approve\n</code></pre> <p>Additional task files, such as <code>Taskfile.gitflow.yml</code>, provide specialized functionality.</p>"},{"location":"automation/taskfile/#core-tasks","title":"Core Tasks","text":""},{"location":"automation/taskfile/#cluster-management","title":"Cluster Management","text":"Task Description <code>task create-cluster</code> Creates a Kind cluster for local development <code>task delete-cluster</code> Deletes the Kind cluster <code>task expose-kubeconfig</code> Exports the kubeconfig to a file"},{"location":"automation/taskfile/#argocd-management","title":"ArgoCD Management","text":"Task Description <code>task install-argocd</code> Installs ArgoCD using Terraform <code>task forward-argocd-ui</code> Forwards the ArgoCD UI to localhost:8080 <code>task argocd-init-passwd</code> Retrieves the initial admin password"},{"location":"automation/taskfile/#utility-tasks","title":"Utility Tasks","text":"Task Description <code>task ports</code> Lists all in-use ports <code>task default</code> Shows all available tasks"},{"location":"automation/taskfile/#gitflow-tasks","title":"GitFlow Tasks","text":"<p>The project includes GitFlow automation in <code>Taskfile.gitflow.yml</code>:</p> <pre><code>version: '3'\ntasks:\n  feature-start:\n    desc: \"Start a new feature branch\"\n    cmds:\n      - git checkout -b feature/{{.FEATURE_NAME}}\n    vars:\n      FEATURE_NAME:\n        sh: echo \"{{.CLI_ARGS}}\"\n\n  feature-finish:\n    desc: \"Finish a feature branch\"\n    cmds:\n      - git checkout main\n      - git merge --no-ff feature/{{.FEATURE_NAME}}\n      - git branch -d feature/{{.FEATURE_NAME}}\n    vars:\n      FEATURE_NAME:\n        sh: echo \"{{.CLI_ARGS}}\"\n</code></pre> <p>These tasks automate Git workflow operations following the GitFlow branching model.</p>"},{"location":"automation/taskfile/#task-dependencies","title":"Task Dependencies","text":"<p>Tasks can depend on other tasks, ensuring prerequisites are met:</p> <pre><code>install-argocd:\n  desc: \"Install or update Argo CD using Terraform\"\n  dir: terraform\n  deps:\n    - create-cluster\n  cmds:\n    - terraform init\n    - terraform apply -auto-approve\n</code></pre> <p>In this example, <code>install-argocd</code> depends on <code>create-cluster</code>, ensuring the cluster exists before attempting to install ArgoCD.</p>"},{"location":"automation/taskfile/#task-variables","title":"Task Variables","text":"<p>Tasks can use variables for dynamic behavior:</p> <pre><code>feature-start:\n  desc: \"Start a new feature branch\"\n  cmds:\n    - git checkout -b feature/{{.FEATURE_NAME}}\n  vars:\n    FEATURE_NAME:\n      sh: echo \"{{.CLI_ARGS}}\"\n</code></pre> <p>Variables can be: - Defined inline - Derived from command-line arguments - Generated from shell commands - Set from environment variables</p>"},{"location":"automation/taskfile/#task-execution","title":"Task Execution","text":"<p>Tasks are executed using the <code>task</code> command:</p> <pre><code># Run the default task\ntask\n\n# Run a specific task\ntask create-cluster\n\n# Run a task with arguments\ntask feature-start my-new-feature\n</code></pre>"},{"location":"automation/taskfile/#extending-task-automation","title":"Extending Task Automation","text":"<p>To add new tasks:</p> <ol> <li>Edit the appropriate Taskfile (e.g., <code>Taskfile.yml</code>)</li> <li>Define the new task with a description and commands</li> <li>Add any dependencies or variables needed</li> <li>Save the file and run <code>task --list-all</code> to verify</li> </ol> <p>Example of adding a new task:</p> <pre><code>deploy-app:\n  desc: \"Deploy a sample application\"\n  deps:\n    - install-argocd\n  cmds:\n    - kubectl apply -f 0-application.yaml\n    - kubectl apply -f 1-application.yaml\n</code></pre>"},{"location":"automation/taskfile/#best-practices","title":"Best Practices","text":"<ol> <li>Descriptive Names: Use clear, descriptive names for tasks</li> <li>Add Descriptions: Include a description for each task</li> <li>Use Dependencies: Define task dependencies explicitly</li> <li>Idempotent Commands: Make tasks safe to run multiple times</li> <li>Status Checks: Use status checks to avoid unnecessary work</li> <li>Organize Tasks: Group related tasks in separate Taskfiles</li> <li>Document Tasks: Include task documentation in project docs</li> </ol>"},{"location":"automation/taskfile/#related-documentation","title":"Related Documentation","text":"<ul> <li>Installation Guide</li> <li>ArgoCD Overview</li> <li>Architecture Overview</li> </ul>"},{"location":"helm/structure/","title":"Helm Chart Structure","text":"<p>This document explains the structure and organization of Helm charts used in the ArgoCD demonstration project.</p>"},{"location":"helm/structure/#overview","title":"Overview","text":"<p>Helm is a package manager for Kubernetes that allows you to define, install, and upgrade complex Kubernetes applications. This project uses Helm charts to package applications for deployment through ArgoCD.</p>"},{"location":"helm/structure/#chart-location","title":"Chart Location","text":"<p>Helm charts in this project are stored in the environment-specific directories:</p> <pre><code>environments/\n\u2514\u2500\u2500 dev/\n    \u2514\u2500\u2500 helm/\n        \u2514\u2500\u2500 myargoapp-chart/\n            \u251c\u2500\u2500 Chart.yaml\n            \u251c\u2500\u2500 values.yaml\n            \u251c\u2500\u2500 templates/\n            \u2502   \u251c\u2500\u2500 deployment.yaml\n            \u2502   \u251c\u2500\u2500 service.yaml\n            \u2502   \u2514\u2500\u2500 _helpers.tpl\n            \u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"helm/structure/#standard-chart-structure","title":"Standard Chart Structure","text":"<p>A Helm chart follows this standard structure:</p> <pre><code>myargoapp-chart/\n\u251c\u2500\u2500 Chart.yaml           # Metadata about the chart\n\u251c\u2500\u2500 values.yaml          # Default configuration values\n\u251c\u2500\u2500 templates/           # Templated Kubernetes YAML files\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service.yaml\n\u2502   \u2514\u2500\u2500 _helpers.tpl     # Reusable template snippets\n\u251c\u2500\u2500 charts/              # Dependencies (optional)\n\u2514\u2500\u2500 README.md            # Documentation\n</code></pre>"},{"location":"helm/structure/#key-components","title":"Key Components","text":""},{"location":"helm/structure/#chartyaml","title":"Chart.yaml","text":"<p>The <code>Chart.yaml</code> file contains metadata about the chart:</p> <pre><code>apiVersion: v2\nname: myargoapp-chart\ndescription: A Helm chart for deploying the MyArgoApp application\ntype: application\nversion: 0.1.0\nappVersion: \"1.0.0\"\n</code></pre> <p>Key fields: - apiVersion: Helm API version (v2 for Helm 3) - name: Name of the chart - description: Description of the chart - type: Type of chart (application or library) - version: Chart version - appVersion: Application version</p>"},{"location":"helm/structure/#valuesyaml","title":"values.yaml","text":"<p>The <code>values.yaml</code> file contains default configuration values:</p> <pre><code>replicaCount: 1\n\nimage:\n  repository: nginx\n  pullPolicy: IfNotPresent\n  tag: \"1.21.0\"\n\nservice:\n  type: ClusterIP\n  port: 80\n\nresources:\n  limits:\n    cpu: 100m\n    memory: 128Mi\n  requests:\n    cpu: 50m\n    memory: 64Mi\n</code></pre> <p>These values can be overridden at deployment time.</p>"},{"location":"helm/structure/#templates","title":"Templates","text":"<p>The <code>templates/</code> directory contains Kubernetes manifest templates:</p>"},{"location":"helm/structure/#deploymentyaml","title":"deployment.yaml","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"myargoapp-chart.fullname\" . }}\n  labels:\n    {{- include \"myargoapp-chart.labels\" . | nindent 4 }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      {{- include \"myargoapp-chart.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      labels:\n        {{- include \"myargoapp-chart.selectorLabels\" . | nindent 8 }}\n    spec:\n      containers:\n        - name: {{ .Chart.Name }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}\"\n          imagePullPolicy: {{ .Values.image.pullPolicy }}\n          ports:\n            - name: http\n              containerPort: 80\n              protocol: TCP\n          resources:\n            {{- toYaml .Values.resources | nindent 12 }}\n</code></pre>"},{"location":"helm/structure/#serviceyaml","title":"service.yaml","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: {{ include \"myargoapp-chart.fullname\" . }}\n  labels:\n    {{- include \"myargoapp-chart.labels\" . | nindent 4 }}\nspec:\n  type: {{ .Values.service.type }}\n  ports:\n    - port: {{ .Values.service.port }}\n      targetPort: http\n      protocol: TCP\n      name: http\n  selector:\n    {{- include \"myargoapp-chart.selectorLabels\" . | nindent 4 }}\n</code></pre>"},{"location":"helm/structure/#_helperstpl","title":"_helpers.tpl","text":"<p>Helper templates provide reusable snippets:</p> <pre><code>{{/* Generate basic labels */}}\n{{- define \"myargoapp-chart.labels\" -}}\nhelm.sh/chart: {{ include \"myargoapp-chart.chart\" . }}\n{{ include \"myargoapp-chart.selectorLabels\" . }}\napp.kubernetes.io/version: {{ .Chart.AppVersion | quote }}\napp.kubernetes.io/managed-by: {{ .Release.Service }}\n{{- end -}}\n\n{{/* Selector labels */}}\n{{- define \"myargoapp-chart.selectorLabels\" -}}\napp.kubernetes.io/name: {{ include \"myargoapp-chart.name\" . }}\napp.kubernetes.io/instance: {{ .Release.Name }}\n{{- end -}}\n</code></pre>"},{"location":"helm/structure/#argocd-integration","title":"ArgoCD Integration","text":"<p>ArgoCD can deploy Helm charts in two ways:</p> <ol> <li>Helm Chart Repository: ArgoCD pulls the chart from a Helm repository</li> <li>Git Repository: ArgoCD uses the chart directly from Git</li> </ol> <p>This project uses the Git repository approach, with ArgoCD configured to use the chart from the project repository:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: myargoapp-0\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/sean-njela/argocd-demo.git\n    targetRevision: HEAD\n    path: environments/dev/helm/myargoapp-chart\n    helm:\n      valueFiles:\n        - values.yaml\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: myapp-0\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre>"},{"location":"helm/structure/#chart-dependencies","title":"Chart Dependencies","text":"<p>Charts can depend on other charts, defined in the <code>Chart.yaml</code> file:</p> <pre><code>dependencies:\n  - name: postgresql\n    version: 10.3.11\n    repository: https://charts.bitnami.com/bitnami\n    condition: postgresql.enabled\n</code></pre> <p>Dependencies are stored in the <code>charts/</code> directory after running:</p> <pre><code>helm dependency update\n</code></pre>"},{"location":"helm/structure/#environment-specific-values","title":"Environment-Specific Values","text":"<p>Different environments can use the same chart with different values:</p> <pre><code>environments/\n\u251c\u2500\u2500 dev/\n\u2502   \u2514\u2500\u2500 helm/\n\u2502       \u2514\u2500\u2500 myargoapp-chart/\n\u2502           \u2514\u2500\u2500 values.yaml  # Development values\n\u2514\u2500\u2500 prod/\n    \u2514\u2500\u2500 helm/\n        \u2514\u2500\u2500 myargoapp-chart/\n            \u2514\u2500\u2500 values.yaml  # Production values\n</code></pre>"},{"location":"helm/structure/#best-practices","title":"Best Practices","text":"<ol> <li>Version Control: Keep charts in version control</li> <li>Documentation: Document chart purpose and values</li> <li>Validation: Validate templates with <code>helm lint</code> and <code>helm template</code></li> <li>Reusable Helpers: Use helper templates for common patterns</li> <li>Default Values: Provide sensible defaults in <code>values.yaml</code></li> <li>Resource Limits: Always specify resource requests and limits</li> <li>Labels and Annotations: Use consistent labeling</li> <li>Security Context: Define security contexts for containers</li> <li>Health Checks: Include readiness and liveness probes</li> <li>Versioning: Update chart version when making changes</li> </ol>"},{"location":"helm/structure/#related-documentation","title":"Related Documentation","text":"<ul> <li>Application Deployment</li> <li>ArgoCD Overview</li> <li>System Architecture</li> </ul>"},{"location":"infrastructure/terraform/","title":"Terraform Configuration","text":"<p>This document details the Terraform infrastructure as code implementation used to provision and manage ArgoCD in the Kubernetes cluster.</p>"},{"location":"infrastructure/terraform/#overview","title":"Overview","text":"<p>Terraform is used in this project to provide a reproducible, version-controlled approach to infrastructure provisioning. The primary focus is on installing and configuring ArgoCD in the Kubernetes cluster.</p>"},{"location":"infrastructure/terraform/#directory-structure","title":"Directory Structure","text":"<pre><code>terraform/\n\u251c\u2500\u2500 0-provider.tf       # Provider configuration\n\u251c\u2500\u2500 1-argocd.tf         # ArgoCD installation\n\u251c\u2500\u2500 values/             # Helm chart values\n\u2502   \u2514\u2500\u2500 argocd-values.yaml  # ArgoCD configuration values\n\u251c\u2500\u2500 .terraform/         # Terraform state directory (gitignored)\n\u251c\u2500\u2500 terraform.tfstate   # Terraform state file\n\u2514\u2500\u2500 .terraform.lock.hcl # Dependency lock file\n</code></pre>"},{"location":"infrastructure/terraform/#provider-configuration","title":"Provider Configuration","text":"<p>The project uses the Kubernetes and Helm providers to interact with the Kind cluster:</p> <pre><code># From 0-provider.tf\nprovider \"kubernetes\" {\n  config_path = \"~/.kube/config\"\n  config_context = \"kind-argocd-demo\"\n}\n\nprovider \"helm\" {\n  kubernetes {\n    config_path = \"~/.kube/config\"\n    config_context = \"kind-argocd-demo\"\n  }\n}\n</code></pre>"},{"location":"infrastructure/terraform/#argocd-installation","title":"ArgoCD Installation","text":"<p>ArgoCD is installed using the official Helm chart through Terraform:</p> <pre><code># From 1-argocd.tf\nresource \"helm_release\" \"argocd\" {\n    name = \"argocd\"\n    repository = \"https://argoproj.github.io/argo-helm\"\n    chart = \"argo-cd\"\n    version = \"3.35.4\"\n    namespace = \"argocd\"\n    create_namespace = true\n    values = [file(\"values/argocd-values.yaml\")]\n}\n</code></pre> <p>This approach offers several benefits: - Version Pinning: Specific ArgoCD version (3.35.4) ensures consistency - Namespace Management: Creates the ArgoCD namespace if it doesn't exist - Configuration as Code: Uses values file for customization - Reproducibility: Same installation can be reproduced on any cluster</p>"},{"location":"infrastructure/terraform/#helm-chart-values","title":"Helm Chart Values","text":"<p>The ArgoCD Helm chart is configured using values specified in <code>values/argocd-values.yaml</code>. Key configurations include:</p> <ul> <li>Server configuration</li> <li>RBAC settings</li> <li>Resource limits</li> <li>High availability settings (disabled for demo)</li> <li>UI customization</li> <li>Authentication settings</li> </ul>"},{"location":"infrastructure/terraform/#execution-flow","title":"Execution Flow","text":"<p>When running <code>task install-argocd</code>, the following happens:</p> <ol> <li>Task runner executes commands in the terraform directory</li> <li>Terraform initializes providers and modules</li> <li>Terraform applies the configuration:</li> <li>Creates the ArgoCD namespace</li> <li>Installs ArgoCD using the Helm chart</li> <li>Applies custom configuration values</li> </ol>"},{"location":"infrastructure/terraform/#alternative-approaches","title":"Alternative Approaches","text":"<p>While Terraform is used in this project, the documentation notes alternative approaches that could be used:</p> <pre><code># Direct kubectl approach\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n\n# Direct Helm approach\nhelm repo add argocd https://argoproj.github.io/argo-helm\nhelm repo update\nhelm install argocd -n argocd --create-namespace argocd/argo-cd --version 3.35.4\n</code></pre> <p>Terraform was chosen for this project because: - It provides better dependency management - Configuration is more maintainable as code - It integrates well with the GitOps workflow - It allows for more complex provisioning logic</p>"},{"location":"infrastructure/terraform/#best-practices-implemented","title":"Best Practices Implemented","text":"<ol> <li>Version Pinning: Specific versions for providers and charts</li> <li>Modular Structure: Separate files for different concerns</li> <li>Value Externalization: Configuration values in separate files</li> <li>Resource Naming: Consistent naming conventions</li> <li>State Management: Proper handling of Terraform state</li> </ol>"},{"location":"infrastructure/terraform/#extending-the-infrastructure","title":"Extending the Infrastructure","text":"<p>To extend the infrastructure:</p> <ol> <li>Add new <code>.tf</code> files for additional components</li> <li>Update or create values files for configuration</li> <li>Apply changes using <code>terraform apply</code> or through the task runner</li> </ol>"},{"location":"infrastructure/terraform/#related-documentation","title":"Related Documentation","text":"<ul> <li>ArgoCD Overview</li> <li>System Architecture</li> <li>Getting Started</li> </ul>"},{"location":"quickstart/getting-started/","title":"Getting Started with ArgoCD Demo","text":"<p>This guide will help you quickly get started with this ArgoCD demonstration project. Follow these steps to set up your environment and deploy your first application.</p>"},{"location":"quickstart/getting-started/#overview","title":"Overview","text":"<p>This project demonstrates GitOps principles using ArgoCD on a Kubernetes cluster. The setup includes:</p> <ul> <li>A local Kubernetes cluster using Kind</li> <li>ArgoCD installed via Terraform</li> <li>Sample applications deployed through ArgoCD</li> <li>Helm charts for application packaging</li> <li>Task automation for common operations</li> </ul>"},{"location":"quickstart/getting-started/#quick-setup","title":"Quick Setup","text":"<p>For the fastest path to a working environment, run these commands:</p> <pre><code># Clone the repository\ngit clone https://github.com/sean-njela/argocd-demo.git\ncd argocd-demo\n\n# Create the Kind cluster and install ArgoCD\ntask create-cluster\ntask install-argocd\n\n# Access the ArgoCD UI\ntask forward-argocd-ui\n# In a separate terminal, get the initial admin password\ntask argocd-init-passwd\n</code></pre> <p>The ArgoCD UI will be available at http://localhost:8080.</p>"},{"location":"quickstart/getting-started/#next-steps","title":"Next Steps","text":"<p>After setting up the environment:</p> <ol> <li>Review the prerequisites to ensure your system meets all requirements</li> <li>Follow the detailed installation guide for a step-by-step setup</li> <li>Deploy your first application with ArgoCD by following the Application Deployment Guide</li> <li>Explore the Architecture Overview to understand the system design</li> </ol>"},{"location":"quickstart/getting-started/#project-structure","title":"Project Structure","text":"<pre><code>argocd-demo/\n\u251c\u2500\u2500 terraform/           # Terraform files for ArgoCD installation\n\u251c\u2500\u2500 environments/        # Environment-specific configurations\n\u2502   \u251c\u2500\u2500 dev/             # Development environment\n\u2502   \u2502   \u251c\u2500\u2500 apps/        # Application manifests\n\u2502   \u2502   \u2514\u2500\u2500 helm/        # Helm charts\n\u251c\u2500\u2500 docs/                # Documentation\n\u2514\u2500\u2500 Taskfile.yml         # Task automation definitions\n</code></pre>"},{"location":"quickstart/getting-started/#common-tasks","title":"Common Tasks","text":"Task Description <code>task create-cluster</code> Creates a Kind cluster for local development <code>task install-argocd</code> Installs ArgoCD using Terraform <code>task forward-argocd-ui</code> Forwards the ArgoCD UI to localhost:8080 <code>task argocd-init-passwd</code> Retrieves the initial admin password <code>task expose-kubeconfig</code> Exports the cluster's kubeconfig <p>For a complete list of available tasks, run <code>task --list-all</code>.</p>"},{"location":"quickstart/getting-started/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during setup:</p> <ol> <li>Ensure all prerequisites are installed</li> <li>Check the ArgoCD documentation for troubleshooting tips</li> <li>Review the ArgoCD Overview for configuration details</li> </ol>"},{"location":"quickstart/installation/","title":"Installation Guide","text":"<p>This guide provides detailed instructions for setting up the ArgoCD demonstration environment from scratch.</p>"},{"location":"quickstart/installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>Start by cloning the repository to your local machine:</p> <pre><code>git clone https://github.com/sean-njela/argocd-demo.git\ncd argocd-demo\n</code></pre>"},{"location":"quickstart/installation/#step-2-create-a-kubernetes-cluster","title":"Step 2: Create a Kubernetes Cluster","text":"<p>The project uses Kind (Kubernetes in Docker) to create a local Kubernetes cluster:</p> <pre><code># Create a Kind cluster named argocd-demo\ntask create-cluster\n</code></pre> <p>This command creates a Kubernetes cluster using Kind with the following specifications: - Cluster name: <code>argocd-demo</code> - Kubernetes version: v1.33.1 - Single node configuration</p> <p>You can verify the cluster is running with:</p> <pre><code>kind get clusters\nkubectl cluster-info --context kind-argocd-demo\n</code></pre>"},{"location":"quickstart/installation/#step-3-install-argocd","title":"Step 3: Install ArgoCD","text":"<p>ArgoCD is installed using Terraform to ensure reproducible infrastructure:</p> <pre><code># Install ArgoCD using Terraform\ntask install-argocd\n</code></pre> <p>This command: 1. Initializes Terraform in the <code>terraform/</code> directory 2. Applies the Terraform configuration to install ArgoCD 3. Creates the ArgoCD namespace 4. Deploys ArgoCD using the Helm chart (version 3.35.4) 5. Configures ArgoCD with values from <code>terraform/values/argocd-values.yaml</code></p>"},{"location":"quickstart/installation/#step-4-access-the-argocd-ui","title":"Step 4: Access the ArgoCD UI","text":"<p>To access the ArgoCD web interface:</p> <pre><code># Forward the ArgoCD server to localhost:8080\ntask forward-argocd-ui\n</code></pre> <p>The ArgoCD UI will be available at http://localhost:8080.</p> <p>To retrieve the initial admin password:</p> <pre><code># Get the initial admin password\ntask argocd-init-passwd\n</code></pre> <p>Login with: - Username: <code>admin</code> - Password: (output from the command above)</p>"},{"location":"quickstart/installation/#step-5-deploy-sample-applications","title":"Step 5: Deploy Sample Applications","text":"<p>The project includes sample applications that can be deployed to demonstrate ArgoCD's capabilities:</p> <pre><code># Apply the Application manifests\nkubectl apply -f 0-application.yaml\nkubectl apply -f 1-application.yaml\n</code></pre> <p>These manifests define ArgoCD Applications that point to: - <code>0-application.yaml</code>: A Helm-based application - <code>1-application.yaml</code>: A Kubernetes manifest-based application</p>"},{"location":"quickstart/installation/#step-6-export-kubeconfig-optional","title":"Step 6: Export Kubeconfig (Optional)","text":"<p>If you want to use external tools like Lens to manage your cluster:</p> <pre><code># Export the kubeconfig to a file\ntask expose-kubeconfig\n</code></pre> <p>This creates a <code>config-kind-dev.txt</code> file that can be imported into Kubernetes management tools.</p>"},{"location":"quickstart/installation/#verification","title":"Verification","text":"<p>Verify that all components are running correctly:</p> <pre><code># Check ArgoCD pods\nkubectl get pods -n argocd\n\n# Check ArgoCD applications\nkubectl get applications -n argocd\n</code></pre>"},{"location":"quickstart/installation/#next-steps","title":"Next Steps","text":"<p>After completing the installation:</p> <ol> <li>Explore the ArgoCD UI to see the deployed applications</li> <li>Review the ArgoCD Overview to understand the components</li> <li>Learn about Application Deployment with ArgoCD</li> <li>Explore the Environment Management structure</li> </ol>"},{"location":"quickstart/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation:</p> <ul> <li>Cluster Creation Fails: Ensure Docker is running and has sufficient resources</li> <li>Terraform Errors: Check the Terraform logs in the <code>terraform/</code> directory</li> <li>ArgoCD UI Not Accessible: Verify the port forwarding is active and no other service is using port 8080</li> <li>Application Sync Issues: Check the Application status in the ArgoCD UI or with <code>kubectl get applications -n argocd</code></li> </ul> <p>For more detailed troubleshooting, refer to the ArgoCD official documentation.</p>"},{"location":"quickstart/prerequisites/","title":"Prerequisites","text":"<p>Before you begin with the ArgoCD demonstration project, ensure your system meets the following requirements.</p>"},{"location":"quickstart/prerequisites/#required-tools","title":"Required Tools","text":"Tool Version Purpose Docker 20.10+ Container runtime for Kind Kubernetes 1.23+ Container orchestration Kind 0.14+ Local Kubernetes cluster kubectl 1.23+ Kubernetes CLI Terraform 1.0+ Infrastructure provisioning Helm 3.8+ Package management Task 3.0+ Task automation Git 2.30+ Version control"},{"location":"quickstart/prerequisites/#system-requirements","title":"System Requirements","text":"<ul> <li>CPU: 2+ cores recommended</li> <li>Memory: 4GB+ RAM recommended</li> <li>Disk Space: 10GB+ free space</li> <li>Operating System: Linux, macOS, or Windows with WSL2</li> </ul>"},{"location":"quickstart/prerequisites/#environment-setup","title":"Environment Setup","text":""},{"location":"quickstart/prerequisites/#docker-configuration","title":"Docker Configuration","text":"<p>Ensure Docker is properly configured:</p> <pre><code># Verify Docker installation\ndocker --version\n\n# Ensure Docker daemon is running\ndocker info\n</code></pre>"},{"location":"quickstart/prerequisites/#kubernetes-tools","title":"Kubernetes Tools","text":"<p>Verify Kubernetes tools are installed:</p> <pre><code># Verify kubectl installation\nkubectl version --client\n\n# Verify Kind installation\nkind version\n\n# Verify Helm installation\nhelm version\n</code></pre>"},{"location":"quickstart/prerequisites/#terraform-setup","title":"Terraform Setup","text":"<p>Ensure Terraform is properly installed:</p> <pre><code># Verify Terraform installation\nterraform version\n</code></pre>"},{"location":"quickstart/prerequisites/#task-runner","title":"Task Runner","text":"<p>Verify Task runner is installed:</p> <pre><code># Verify Task installation\ntask --version\n</code></pre>"},{"location":"quickstart/prerequisites/#network-requirements","title":"Network Requirements","text":"<ul> <li>Outbound internet access for downloading container images</li> <li>Available local ports:</li> <li>8080: ArgoCD UI</li> <li>6443: Kubernetes API server</li> </ul>"},{"location":"quickstart/prerequisites/#optional-tools","title":"Optional Tools","text":"<p>These tools are not required but can enhance your experience:</p> <ul> <li>k9s: Terminal-based UI for Kubernetes</li> <li>Lens: Kubernetes IDE for simplified cluster management</li> <li>kubectx/kubens: Tools for switching between contexts and namespaces</li> </ul>"},{"location":"quickstart/prerequisites/#next-steps","title":"Next Steps","text":"<p>Once you've confirmed all prerequisites are met, proceed to the Installation Guide to set up the ArgoCD demonstration environment.</p>"}]}